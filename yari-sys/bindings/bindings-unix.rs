/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const YR_MAX_THREADS: u32 = 32;
pub const YR_MAX_ARENA_BUFFERS: u32 = 16;
pub const YR_MAX_COMPILER_ERROR_EXTRA_INFO: u32 = 256;
pub const YR_MAX_ATOM_LENGTH: u32 = 4;
pub const YR_MAX_ATOM_QUALITY: u32 = 255;
pub const YR_MIN_ATOM_QUALITY: u32 = 0;
pub const YR_ATOM_QUALITY_WARNING_THRESHOLD: u32 = 205;
pub const YR_ATOMS_PER_RULE_WARNING_THRESHOLD: u32 = 12000;
pub const YR_MAX_LOOP_NESTING: u32 = 4;
pub const YR_MAX_LOOP_VARS: u32 = 2;
pub const YR_MAX_INCLUDE_DEPTH: u32 = 16;
pub const YR_MAX_STRING_MATCHES: u32 = 1000000;
pub const YR_MAX_FUNCTION_ARGS: u32 = 128;
pub const YR_MAX_OVERLOADED_FUNCTIONS: u32 = 10;
pub const YR_STRING_CHAINING_THRESHOLD: u32 = 200;
pub const YR_LEX_BUF_SIZE: u32 = 8192;
pub const YR_MATCH_VERIFICATION_PROFILING_RATE: u32 = 1024;
pub const YR_RE_SCAN_LIMIT: u32 = 4096;
pub const YR_ARENA_FILE_VERSION: u32 = 19;
pub const META_TYPE_INTEGER: u32 = 1;
pub const META_TYPE_STRING: u32 = 2;
pub const META_TYPE_BOOLEAN: u32 = 3;
pub const YR_AC_SLOT_OFFSET_BITS: u32 = 9;
pub const YR_AC_MAX_TRANSITION_TABLE_SIZE: u32 = 8388608;
pub const YR_AC_ROOT_STATE: u32 = 0;
pub const YR_NAMESPACES_TABLE: u32 = 0;
pub const YR_RULES_TABLE: u32 = 1;
pub const YR_METAS_TABLE: u32 = 2;
pub const YR_STRINGS_TABLE: u32 = 3;
pub const YR_EXTERNAL_VARIABLES_TABLE: u32 = 4;
pub const YR_SZ_POOL: u32 = 5;
pub const YR_CODE_SECTION: u32 = 6;
pub const YR_RE_CODE_SECTION: u32 = 7;
pub const YR_AC_TRANSITION_TABLE: u32 = 8;
pub const YR_AC_STATE_MATCHES_TABLE: u32 = 9;
pub const YR_AC_STATE_MATCHES_POOL: u32 = 10;
pub const YR_SUMMARY_SECTION: u32 = 11;
pub const YR_NUM_SECTIONS: u32 = 12;
pub const YR_INTERNAL_LOOP_VARS: u32 = 3;
pub const ERROR_SUCCESS: u32 = 0;
pub const ERROR_INSUFICIENT_MEMORY: u32 = 1;
pub const ERROR_INSUFFICIENT_MEMORY: u32 = 1;
pub const ERROR_COULD_NOT_ATTACH_TO_PROCESS: u32 = 2;
pub const ERROR_COULD_NOT_OPEN_FILE: u32 = 3;
pub const ERROR_COULD_NOT_MAP_FILE: u32 = 4;
pub const ERROR_INVALID_FILE: u32 = 6;
pub const ERROR_CORRUPT_FILE: u32 = 7;
pub const ERROR_UNSUPPORTED_FILE_VERSION: u32 = 8;
pub const ERROR_INVALID_REGULAR_EXPRESSION: u32 = 9;
pub const ERROR_INVALID_HEX_STRING: u32 = 10;
pub const ERROR_SYNTAX_ERROR: u32 = 11;
pub const ERROR_LOOP_NESTING_LIMIT_EXCEEDED: u32 = 12;
pub const ERROR_DUPLICATED_LOOP_IDENTIFIER: u32 = 13;
pub const ERROR_DUPLICATED_IDENTIFIER: u32 = 14;
pub const ERROR_DUPLICATED_TAG_IDENTIFIER: u32 = 15;
pub const ERROR_DUPLICATED_META_IDENTIFIER: u32 = 16;
pub const ERROR_DUPLICATED_STRING_IDENTIFIER: u32 = 17;
pub const ERROR_UNREFERENCED_STRING: u32 = 18;
pub const ERROR_UNDEFINED_STRING: u32 = 19;
pub const ERROR_UNDEFINED_IDENTIFIER: u32 = 20;
pub const ERROR_MISPLACED_ANONYMOUS_STRING: u32 = 21;
pub const ERROR_INCLUDES_CIRCULAR_REFERENCE: u32 = 22;
pub const ERROR_INCLUDE_DEPTH_EXCEEDED: u32 = 23;
pub const ERROR_WRONG_TYPE: u32 = 24;
pub const ERROR_EXEC_STACK_OVERFLOW: u32 = 25;
pub const ERROR_SCAN_TIMEOUT: u32 = 26;
pub const ERROR_TOO_MANY_SCAN_THREADS: u32 = 27;
pub const ERROR_CALLBACK_ERROR: u32 = 28;
pub const ERROR_INVALID_ARGUMENT: u32 = 29;
pub const ERROR_TOO_MANY_MATCHES: u32 = 30;
pub const ERROR_INTERNAL_FATAL_ERROR: u32 = 31;
pub const ERROR_NESTED_FOR_OF_LOOP: u32 = 32;
pub const ERROR_INVALID_FIELD_NAME: u32 = 33;
pub const ERROR_UNKNOWN_MODULE: u32 = 34;
pub const ERROR_NOT_A_STRUCTURE: u32 = 35;
pub const ERROR_NOT_INDEXABLE: u32 = 36;
pub const ERROR_NOT_A_FUNCTION: u32 = 37;
pub const ERROR_INVALID_FORMAT: u32 = 38;
pub const ERROR_TOO_MANY_ARGUMENTS: u32 = 39;
pub const ERROR_WRONG_ARGUMENTS: u32 = 40;
pub const ERROR_WRONG_RETURN_TYPE: u32 = 41;
pub const ERROR_DUPLICATED_STRUCTURE_MEMBER: u32 = 42;
pub const ERROR_EMPTY_STRING: u32 = 43;
pub const ERROR_DIVISION_BY_ZERO: u32 = 44;
pub const ERROR_REGULAR_EXPRESSION_TOO_LARGE: u32 = 45;
pub const ERROR_TOO_MANY_RE_FIBERS: u32 = 46;
pub const ERROR_COULD_NOT_READ_PROCESS_MEMORY: u32 = 47;
pub const ERROR_INVALID_EXTERNAL_VARIABLE_TYPE: u32 = 48;
pub const ERROR_REGULAR_EXPRESSION_TOO_COMPLEX: u32 = 49;
pub const ERROR_INVALID_MODULE_NAME: u32 = 50;
pub const ERROR_TOO_MANY_STRINGS: u32 = 51;
pub const ERROR_INTEGER_OVERFLOW: u32 = 52;
pub const ERROR_CALLBACK_REQUIRED: u32 = 53;
pub const ERROR_INVALID_OPERAND: u32 = 54;
pub const ERROR_COULD_NOT_READ_FILE: u32 = 55;
pub const ERROR_DUPLICATED_EXTERNAL_VARIABLE: u32 = 56;
pub const ERROR_INVALID_MODULE_DATA: u32 = 57;
pub const ERROR_WRITING_FILE: u32 = 58;
pub const ERROR_INVALID_MODIFIER: u32 = 59;
pub const ERROR_DUPLICATED_MODIFIER: u32 = 60;
pub const ERROR_BLOCK_NOT_READY: u32 = 61;
pub const ERROR_INVALID_PERCENTAGE: u32 = 62;
pub const ERROR_IDENTIFIER_MATCHES_WILDCARD: u32 = 63;
pub const ERROR_INVALID_VALUE: u32 = 64;
pub const YR_MAJOR_VERSION: u32 = 4;
pub const YR_MINOR_VERSION: u32 = 2;
pub const YR_MICRO_VERSION: u32 = 1;
pub const YR_VERSION_HEX: u32 = 262657;
pub const YR_PARANOID_EXEC: u32 = 1;
pub const YR_UNDEFINED: i64 = -1483400188077313;
pub const OBJECT_TYPE_INTEGER: u32 = 1;
pub const OBJECT_TYPE_STRING: u32 = 2;
pub const OBJECT_TYPE_STRUCTURE: u32 = 3;
pub const OBJECT_TYPE_ARRAY: u32 = 4;
pub const OBJECT_TYPE_FUNCTION: u32 = 5;
pub const OBJECT_TYPE_DICTIONARY: u32 = 6;
pub const OBJECT_TYPE_FLOAT: u32 = 7;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    fn test_field___jmpbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__jmpbuf)
            )
        );
    }
    test_field___jmpbuf();
    fn test_field___mask_was_saved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__mask_was_saved)
            )
        );
    }
    test_field___mask_was_saved();
    fn test_field___saved_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__saved_mask)
            )
        );
    }
    test_field___saved_mask();
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__IO_read_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
    }
    test_field__IO_read_ptr();
    fn test_field__IO_read_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
    }
    test_field__IO_read_end();
    fn test_field__IO_read_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
    }
    test_field__IO_read_base();
    fn test_field__IO_write_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
    }
    test_field__IO_write_base();
    fn test_field__IO_write_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
    }
    test_field__IO_write_ptr();
    fn test_field__IO_write_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
    }
    test_field__IO_write_end();
    fn test_field__IO_buf_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
    }
    test_field__IO_buf_base();
    fn test_field__IO_buf_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
    }
    test_field__IO_buf_end();
    fn test_field__IO_save_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
    }
    test_field__IO_save_base();
    fn test_field__IO_backup_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
    }
    test_field__IO_backup_base();
    fn test_field__IO_save_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
    }
    test_field__IO_save_end();
    fn test_field__markers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
    }
    test_field__markers();
    fn test_field__chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
    }
    test_field__chain();
    fn test_field__fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
    }
    test_field__fileno();
    fn test_field__flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
    }
    test_field__flags2();
    fn test_field__old_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
    }
    test_field__old_offset();
    fn test_field__cur_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
    }
    test_field__cur_column();
    fn test_field__vtable_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
    }
    test_field__vtable_offset();
    fn test_field__shortbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
    }
    test_field__shortbuf();
    fn test_field__lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
    }
    test_field__lock();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
    fn test_field__codecvt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
    }
    test_field__codecvt();
    fn test_field__wide_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
    }
    test_field__wide_data();
    fn test_field__freeres_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
    }
    test_field__freeres_list();
    fn test_field__freeres_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
    }
    test_field__freeres_buf();
    fn test_field___pad5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
    }
    test_field___pad5();
    fn test_field__mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
    }
    test_field__mode();
    fn test_field__unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    test_field__unused2();
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___elision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
    }
    test_field___elision();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type pthread_key_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_STREAM_READ_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        count: size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> size_t,
>;
pub type YR_STREAM_WRITE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        count: size_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> size_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_STREAM {
    pub user_data: *mut ::std::os::raw::c_void,
    pub read: YR_STREAM_READ_FUNC,
    pub write: YR_STREAM_WRITE_FUNC,
}
#[test]
fn bindgen_test_layout__YR_STREAM() {
    assert_eq!(
        ::std::mem::size_of::<_YR_STREAM>(),
        24usize,
        concat!("Size of: ", stringify!(_YR_STREAM))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_STREAM>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_STREAM))
    );
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_STREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_STREAM),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_STREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_STREAM),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_STREAM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_STREAM),
                "::",
                stringify!(write)
            )
        );
    }
    test_field_write();
}
impl Default for _YR_STREAM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_STREAM = _YR_STREAM;
extern "C" {
    pub fn yr_stream_read(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        count: size_t,
        stream: *mut YR_STREAM,
    ) -> size_t;
}
extern "C" {
    pub fn yr_stream_write(
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        count: size_t,
        stream: *mut YR_STREAM,
    ) -> size_t;
}
pub type yr_arena_off_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct YR_ARENA_REF {
    pub buffer_id: u32,
    pub offset: yr_arena_off_t,
}
#[test]
fn bindgen_test_layout_YR_ARENA_REF() {
    assert_eq!(
        ::std::mem::size_of::<YR_ARENA_REF>(),
        8usize,
        concat!("Size of: ", stringify!(YR_ARENA_REF))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ARENA_REF>(),
        4usize,
        concat!("Alignment of ", stringify!(YR_ARENA_REF))
    );
    fn test_field_buffer_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA_REF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA_REF),
                "::",
                stringify!(buffer_id)
            )
        );
    }
    test_field_buffer_id();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA_REF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA_REF),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ARENA_BUFFER {
    pub data: *mut u8,
    pub size: size_t,
    pub used: size_t,
}
#[test]
fn bindgen_test_layout_YR_ARENA_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<YR_ARENA_BUFFER>(),
        24usize,
        concat!("Size of: ", stringify!(YR_ARENA_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ARENA_BUFFER>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ARENA_BUFFER))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA_BUFFER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA_BUFFER),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA_BUFFER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA_BUFFER),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_used() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA_BUFFER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA_BUFFER),
                "::",
                stringify!(used)
            )
        );
    }
    test_field_used();
}
impl Default for YR_ARENA_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_RELOC {
    pub buffer_id: u32,
    pub offset: yr_arena_off_t,
    pub next: *mut YR_RELOC,
}
#[test]
fn bindgen_test_layout_YR_RELOC() {
    assert_eq!(
        ::std::mem::size_of::<YR_RELOC>(),
        16usize,
        concat!("Size of: ", stringify!(YR_RELOC))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RELOC>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RELOC))
    );
    fn test_field_buffer_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RELOC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RELOC),
                "::",
                stringify!(buffer_id)
            )
        );
    }
    test_field_buffer_id();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RELOC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RELOC),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RELOC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RELOC),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
impl Default for YR_RELOC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ARENA {
    pub xrefs: u32,
    pub num_buffers: u32,
    pub buffers: [YR_ARENA_BUFFER; 16usize],
    pub initial_buffer_size: size_t,
    pub reloc_list_head: *mut YR_RELOC,
    pub reloc_list_tail: *mut YR_RELOC,
}
#[test]
fn bindgen_test_layout_YR_ARENA() {
    assert_eq!(
        ::std::mem::size_of::<YR_ARENA>(),
        416usize,
        concat!("Size of: ", stringify!(YR_ARENA))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ARENA>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ARENA))
    );
    fn test_field_xrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xrefs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA),
                "::",
                stringify!(xrefs)
            )
        );
    }
    test_field_xrefs();
    fn test_field_num_buffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_buffers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA),
                "::",
                stringify!(num_buffers)
            )
        );
    }
    test_field_num_buffers();
    fn test_field_buffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA),
                "::",
                stringify!(buffers)
            )
        );
    }
    test_field_buffers();
    fn test_field_initial_buffer_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initial_buffer_size) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA),
                "::",
                stringify!(initial_buffer_size)
            )
        );
    }
    test_field_initial_buffer_size();
    fn test_field_reloc_list_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reloc_list_head) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA),
                "::",
                stringify!(reloc_list_head)
            )
        );
    }
    test_field_reloc_list_head();
    fn test_field_reloc_list_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARENA>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reloc_list_tail) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARENA),
                "::",
                stringify!(reloc_list_tail)
            )
        );
    }
    test_field_reloc_list_tail();
}
impl Default for YR_ARENA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn yr_arena_create(
        num_buffers: u32,
        initial_buffer_size: size_t,
        arena: *mut *mut YR_ARENA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_acquire(arena: *mut YR_ARENA);
}
extern "C" {
    pub fn yr_arena_release(arena: *mut YR_ARENA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_ref_to_ptr(
        arena: *mut YR_ARENA,
        ref_: *mut YR_ARENA_REF,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_arena_ptr_to_ref(
        arena: *mut YR_ARENA,
        address: *const ::std::os::raw::c_void,
        ref_: *mut YR_ARENA_REF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_get_ptr(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        offset: yr_arena_off_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_arena_get_current_offset(arena: *mut YR_ARENA, buffer_id: u32) -> yr_arena_off_t;
}
extern "C" {
    pub fn yr_arena_allocate_memory(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        size: size_t,
        ref_: *mut YR_ARENA_REF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_allocate_zeroed_memory(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        size: size_t,
        ref_: *mut YR_ARENA_REF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_allocate_struct(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        size: size_t,
        ref_: *mut YR_ARENA_REF,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_make_ptr_relocatable(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_write_data(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        data: *const ::std::os::raw::c_void,
        size: size_t,
        ref_: *mut YR_ARENA_REF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_write_string(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        string: *const ::std::os::raw::c_char,
        ref_: *mut YR_ARENA_REF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_write_uint32(
        arena: *mut YR_ARENA,
        buffer_id: u32,
        integer: u32,
        ref_: *mut YR_ARENA_REF,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_load_stream(
        stream: *mut YR_STREAM,
        arena: *mut *mut YR_ARENA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_arena_save_stream(
        arena: *mut YR_ARENA,
        stream: *mut YR_STREAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_bitmask_find_non_colliding_offset(
        a: *mut ::std::os::raw::c_ulong,
        b: *mut ::std::os::raw::c_ulong,
        len_a: u32,
        len_b: u32,
        off_a: *mut u32,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_HASH_TABLE_ENTRY {
    pub key: *mut ::std::os::raw::c_void,
    pub key_length: size_t,
    pub ns: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_void,
    pub next: *mut _YR_HASH_TABLE_ENTRY,
}
#[test]
fn bindgen_test_layout__YR_HASH_TABLE_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_YR_HASH_TABLE_ENTRY>(),
        40usize,
        concat!("Size of: ", stringify!(_YR_HASH_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_HASH_TABLE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_HASH_TABLE_ENTRY))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_HASH_TABLE_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_HASH_TABLE_ENTRY),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_key_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_HASH_TABLE_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_HASH_TABLE_ENTRY),
                "::",
                stringify!(key_length)
            )
        );
    }
    test_field_key_length();
    fn test_field_ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_HASH_TABLE_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_HASH_TABLE_ENTRY),
                "::",
                stringify!(ns)
            )
        );
    }
    test_field_ns();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_HASH_TABLE_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_HASH_TABLE_ENTRY),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_HASH_TABLE_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_HASH_TABLE_ENTRY),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
impl Default for _YR_HASH_TABLE_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_HASH_TABLE_ENTRY = _YR_HASH_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_HASH_TABLE {
    pub size: ::std::os::raw::c_int,
    pub buckets: [*mut YR_HASH_TABLE_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__YR_HASH_TABLE() {
    assert_eq!(
        ::std::mem::size_of::<_YR_HASH_TABLE>(),
        16usize,
        concat!("Size of: ", stringify!(_YR_HASH_TABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_HASH_TABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_HASH_TABLE))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_HASH_TABLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_HASH_TABLE),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_buckets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_HASH_TABLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buckets) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_HASH_TABLE),
                "::",
                stringify!(buckets)
            )
        );
    }
    test_field_buckets();
}
impl Default for _YR_HASH_TABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_HASH_TABLE = _YR_HASH_TABLE;
pub type YR_HASH_TABLE_FREE_VALUE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(value: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type YR_HASH_TABLE_ITERATE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        key: *mut ::std::os::raw::c_void,
        key_length: size_t,
        value: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn yr_hash(seed: u32, buffer: *const ::std::os::raw::c_void, len: size_t) -> u32;
}
extern "C" {
    pub fn yr_hash_table_create(
        size: ::std::os::raw::c_int,
        table: *mut *mut YR_HASH_TABLE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_hash_table_clean(
        table: *mut YR_HASH_TABLE,
        free_value: YR_HASH_TABLE_FREE_VALUE_FUNC,
    );
}
extern "C" {
    pub fn yr_hash_table_destroy(
        table: *mut YR_HASH_TABLE,
        free_value: YR_HASH_TABLE_FREE_VALUE_FUNC,
    );
}
extern "C" {
    pub fn yr_hash_table_iterate(
        table: *mut YR_HASH_TABLE,
        ns: *const ::std::os::raw::c_char,
        iterate_func: YR_HASH_TABLE_ITERATE_FUNC,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_hash_table_lookup(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_hash_table_remove(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_hash_table_add(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_hash_table_add_uint32(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_hash_table_lookup_uint32(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_char,
        ns: *const ::std::os::raw::c_char,
    ) -> u32;
}
extern "C" {
    pub fn yr_hash_table_lookup_raw_key(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_void,
        key_length: size_t,
        ns: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_hash_table_remove_raw_key(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_void,
        key_length: size_t,
        ns: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_hash_table_add_raw_key(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_void,
        key_length: size_t,
        ns: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_hash_table_add_uint32_raw_key(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_void,
        key_length: size_t,
        ns: *const ::std::os::raw::c_char,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_hash_table_lookup_uint32_raw_key(
        table: *mut YR_HASH_TABLE,
        key: *const ::std::os::raw::c_void,
        key_length: size_t,
        ns: *const ::std::os::raw::c_char,
    ) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _YR_STOPWATCH {
    pub __bindgen_anon_1: _YR_STOPWATCH__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _YR_STOPWATCH__bindgen_ty_1 {
    pub tv_start: timeval,
    pub ts_start: timespec,
}
#[test]
fn bindgen_test_layout__YR_STOPWATCH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_YR_STOPWATCH__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_YR_STOPWATCH__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_STOPWATCH__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_STOPWATCH__bindgen_ty_1))
    );
    fn test_field_tv_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_STOPWATCH__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_STOPWATCH__bindgen_ty_1),
                "::",
                stringify!(tv_start)
            )
        );
    }
    test_field_tv_start();
    fn test_field_ts_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_STOPWATCH__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_STOPWATCH__bindgen_ty_1),
                "::",
                stringify!(ts_start)
            )
        );
    }
    test_field_ts_start();
}
impl Default for _YR_STOPWATCH__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__YR_STOPWATCH() {
    assert_eq!(
        ::std::mem::size_of::<_YR_STOPWATCH>(),
        16usize,
        concat!("Size of: ", stringify!(_YR_STOPWATCH))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_STOPWATCH>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_STOPWATCH))
    );
}
impl Default for _YR_STOPWATCH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_STOPWATCH = _YR_STOPWATCH;
extern "C" {
    pub fn yr_stopwatch_start(stopwatch: *mut YR_STOPWATCH);
}
extern "C" {
    pub fn yr_stopwatch_elapsed_ns(stopwatch: *mut YR_STOPWATCH) -> u64;
}
pub type YR_THREAD_ID = pthread_t;
pub type YR_THREAD_STORAGE_KEY = pthread_key_t;
pub type YR_MUTEX = pthread_mutex_t;
extern "C" {
    pub fn yr_current_thread_id() -> YR_THREAD_ID;
}
extern "C" {
    pub fn yr_mutex_create(arg1: *mut YR_MUTEX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_mutex_destroy(arg1: *mut YR_MUTEX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_mutex_lock(arg1: *mut YR_MUTEX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_mutex_unlock(arg1: *mut YR_MUTEX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_thread_storage_create(arg1: *mut YR_THREAD_STORAGE_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_thread_storage_destroy(arg1: *mut YR_THREAD_STORAGE_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_thread_storage_set_value(
        arg1: *mut YR_THREAD_STORAGE_KEY,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_thread_storage_get_value(
        arg1: *mut YR_THREAD_STORAGE_KEY,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_NOTEBOOK {
    _unused: [u8; 0],
}
extern "C" {
    pub fn yr_notebook_create(
        page_size: size_t,
        pool: *mut *mut YR_NOTEBOOK,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_notebook_destroy(pool: *mut YR_NOTEBOOK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_notebook_alloc(
        notebook: *mut YR_NOTEBOOK,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_AC_TABLES {
    _unused: [u8; 0],
}
pub type YR_AC_TRANSITION = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_NAMESPACE {
    pub __bindgen_anon_1: YR_NAMESPACE__bindgen_ty_1,
    pub idx: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_NAMESPACE__bindgen_ty_1 {
    pub name: *const ::std::os::raw::c_char,
    pub name_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_NAMESPACE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_NAMESPACE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(YR_NAMESPACE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_NAMESPACE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_NAMESPACE__bindgen_ty_1))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_NAMESPACE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_NAMESPACE__bindgen_ty_1),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_name_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_NAMESPACE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_NAMESPACE__bindgen_ty_1),
                "::",
                stringify!(name_)
            )
        );
    }
    test_field_name_();
}
impl Default for YR_NAMESPACE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_NAMESPACE() {
    assert_eq!(
        ::std::mem::size_of::<YR_NAMESPACE>(),
        16usize,
        concat!("Size of: ", stringify!(YR_NAMESPACE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_NAMESPACE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_NAMESPACE))
    );
    fn test_field_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_NAMESPACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_NAMESPACE),
                "::",
                stringify!(idx)
            )
        );
    }
    test_field_idx();
}
impl Default for YR_NAMESPACE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_META {
    pub __bindgen_anon_1: YR_META__bindgen_ty_1,
    pub __bindgen_anon_2: YR_META__bindgen_ty_2,
    pub integer: i64,
    pub type_: i32,
    pub flags: i32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_META__bindgen_ty_1 {
    pub identifier: *const ::std::os::raw::c_char,
    pub identifier_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_META__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_META__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(YR_META__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_META__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_META__bindgen_ty_1))
    );
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_META__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_META__bindgen_ty_1),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_identifier_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_META__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_META__bindgen_ty_1),
                "::",
                stringify!(identifier_)
            )
        );
    }
    test_field_identifier_();
}
impl Default for YR_META__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_META__bindgen_ty_2 {
    pub string: *const ::std::os::raw::c_char,
    pub string_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_META__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<YR_META__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(YR_META__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_META__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_META__bindgen_ty_2))
    );
    fn test_field_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_META__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_META__bindgen_ty_2),
                "::",
                stringify!(string)
            )
        );
    }
    test_field_string();
    fn test_field_string_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_META__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_META__bindgen_ty_2),
                "::",
                stringify!(string_)
            )
        );
    }
    test_field_string_();
}
impl Default for YR_META__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_META() {
    assert_eq!(
        ::std::mem::size_of::<YR_META>(),
        32usize,
        concat!("Size of: ", stringify!(YR_META))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_META>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_META))
    );
    fn test_field_integer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_META>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_META),
                "::",
                stringify!(integer)
            )
        );
    }
    test_field_integer();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_META>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_META),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_META>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_META),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for YR_META {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_STRING {
    pub flags: u32,
    pub idx: u32,
    pub fixed_offset: i64,
    pub rule_idx: u32,
    pub length: i32,
    pub __bindgen_anon_1: YR_STRING__bindgen_ty_1,
    pub __bindgen_anon_2: YR_STRING__bindgen_ty_2,
    pub chain_gap_min: i32,
    pub chain_gap_max: i32,
    pub __bindgen_anon_3: YR_STRING__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_STRING__bindgen_ty_1 {
    pub string: *mut u8,
    pub string_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_STRING__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_STRING__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(YR_STRING__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_STRING__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_STRING__bindgen_ty_1))
    );
    fn test_field_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING__bindgen_ty_1),
                "::",
                stringify!(string)
            )
        );
    }
    test_field_string();
    fn test_field_string_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING__bindgen_ty_1),
                "::",
                stringify!(string_)
            )
        );
    }
    test_field_string_();
}
impl Default for YR_STRING__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_STRING__bindgen_ty_2 {
    pub chained_to: *mut YR_STRING,
    pub chained_to_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_STRING__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<YR_STRING__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(YR_STRING__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_STRING__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_STRING__bindgen_ty_2))
    );
    fn test_field_chained_to() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chained_to) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING__bindgen_ty_2),
                "::",
                stringify!(chained_to)
            )
        );
    }
    test_field_chained_to();
    fn test_field_chained_to_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chained_to_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING__bindgen_ty_2),
                "::",
                stringify!(chained_to_)
            )
        );
    }
    test_field_chained_to_();
}
impl Default for YR_STRING__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_STRING__bindgen_ty_3 {
    pub identifier: *const ::std::os::raw::c_char,
    pub identifier_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_STRING__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<YR_STRING__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(YR_STRING__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_STRING__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_STRING__bindgen_ty_3))
    );
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING__bindgen_ty_3),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_identifier_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING__bindgen_ty_3),
                "::",
                stringify!(identifier_)
            )
        );
    }
    test_field_identifier_();
}
impl Default for YR_STRING__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_STRING() {
    assert_eq!(
        ::std::mem::size_of::<YR_STRING>(),
        56usize,
        concat!("Size of: ", stringify!(YR_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_STRING))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING),
                "::",
                stringify!(idx)
            )
        );
    }
    test_field_idx();
    fn test_field_fixed_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fixed_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING),
                "::",
                stringify!(fixed_offset)
            )
        );
    }
    test_field_fixed_offset();
    fn test_field_rule_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rule_idx) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING),
                "::",
                stringify!(rule_idx)
            )
        );
    }
    test_field_rule_idx();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_chain_gap_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chain_gap_min) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING),
                "::",
                stringify!(chain_gap_min)
            )
        );
    }
    test_field_chain_gap_min();
    fn test_field_chain_gap_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chain_gap_max) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING),
                "::",
                stringify!(chain_gap_max)
            )
        );
    }
    test_field_chain_gap_max();
}
impl Default for YR_STRING {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_RULE {
    pub flags: i32,
    pub num_atoms: i32,
    pub __bindgen_anon_1: YR_RULE__bindgen_ty_1,
    pub __bindgen_anon_2: YR_RULE__bindgen_ty_2,
    pub __bindgen_anon_3: YR_RULE__bindgen_ty_3,
    pub __bindgen_anon_4: YR_RULE__bindgen_ty_4,
    pub __bindgen_anon_5: YR_RULE__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULE__bindgen_ty_1 {
    pub identifier: *const ::std::os::raw::c_char,
    pub identifier_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_RULE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULE__bindgen_ty_1))
    );
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_1),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_identifier_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_1),
                "::",
                stringify!(identifier_)
            )
        );
    }
    test_field_identifier_();
}
impl Default for YR_RULE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULE__bindgen_ty_2 {
    pub tags: *const ::std::os::raw::c_char,
    pub tags_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_RULE__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULE__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULE__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULE__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULE__bindgen_ty_2))
    );
    fn test_field_tags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_2),
                "::",
                stringify!(tags)
            )
        );
    }
    test_field_tags();
    fn test_field_tags_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tags_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_2),
                "::",
                stringify!(tags_)
            )
        );
    }
    test_field_tags_();
}
impl Default for YR_RULE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULE__bindgen_ty_3 {
    pub metas: *mut YR_META,
    pub metas_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_RULE__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULE__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULE__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULE__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULE__bindgen_ty_3))
    );
    fn test_field_metas() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).metas) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_3),
                "::",
                stringify!(metas)
            )
        );
    }
    test_field_metas();
    fn test_field_metas_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).metas_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_3),
                "::",
                stringify!(metas_)
            )
        );
    }
    test_field_metas_();
}
impl Default for YR_RULE__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULE__bindgen_ty_4 {
    pub strings: *mut YR_STRING,
    pub strings_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_RULE__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULE__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULE__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULE__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULE__bindgen_ty_4))
    );
    fn test_field_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_4),
                "::",
                stringify!(strings)
            )
        );
    }
    test_field_strings();
    fn test_field_strings_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_4),
                "::",
                stringify!(strings_)
            )
        );
    }
    test_field_strings_();
}
impl Default for YR_RULE__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULE__bindgen_ty_5 {
    pub ns: *mut YR_NAMESPACE,
    pub ns_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_RULE__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULE__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULE__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULE__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULE__bindgen_ty_5))
    );
    fn test_field_ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_5),
                "::",
                stringify!(ns)
            )
        );
    }
    test_field_ns();
    fn test_field_ns_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE__bindgen_ty_5),
                "::",
                stringify!(ns_)
            )
        );
    }
    test_field_ns_();
}
impl Default for YR_RULE__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_RULE() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULE>(),
        48usize,
        concat!("Size of: ", stringify!(YR_RULE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULE))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_num_atoms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_atoms) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE),
                "::",
                stringify!(num_atoms)
            )
        );
    }
    test_field_num_atoms();
}
impl Default for YR_RULE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct YR_SUMMARY {
    pub num_rules: u32,
    pub num_strings: u32,
    pub num_namespaces: u32,
}
#[test]
fn bindgen_test_layout_YR_SUMMARY() {
    assert_eq!(
        ::std::mem::size_of::<YR_SUMMARY>(),
        12usize,
        concat!("Size of: ", stringify!(YR_SUMMARY))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_SUMMARY>(),
        4usize,
        concat!("Alignment of ", stringify!(YR_SUMMARY))
    );
    fn test_field_num_rules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SUMMARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_rules) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SUMMARY),
                "::",
                stringify!(num_rules)
            )
        );
    }
    test_field_num_rules();
    fn test_field_num_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SUMMARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_strings) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SUMMARY),
                "::",
                stringify!(num_strings)
            )
        );
    }
    test_field_num_strings();
    fn test_field_num_namespaces() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SUMMARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_namespaces) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SUMMARY),
                "::",
                stringify!(num_namespaces)
            )
        );
    }
    test_field_num_namespaces();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_EXTERNAL_VARIABLE {
    pub type_: i32,
    pub value: YR_EXTERNAL_VARIABLE__bindgen_ty_1,
    pub __bindgen_anon_1: YR_EXTERNAL_VARIABLE__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_EXTERNAL_VARIABLE__bindgen_ty_1 {
    pub i: i64,
    pub f: f64,
    pub s: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_YR_EXTERNAL_VARIABLE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_EXTERNAL_VARIABLE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_EXTERNAL_VARIABLE__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_1)
        )
    );
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<YR_EXTERNAL_VARIABLE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_1),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
    fn test_field_f() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<YR_EXTERNAL_VARIABLE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_1),
                "::",
                stringify!(f)
            )
        );
    }
    test_field_f();
    fn test_field_s() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<YR_EXTERNAL_VARIABLE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_1),
                "::",
                stringify!(s)
            )
        );
    }
    test_field_s();
}
impl Default for YR_EXTERNAL_VARIABLE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_EXTERNAL_VARIABLE__bindgen_ty_2 {
    pub identifier: *const ::std::os::raw::c_char,
    pub identifier_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_EXTERNAL_VARIABLE__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<YR_EXTERNAL_VARIABLE__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_EXTERNAL_VARIABLE__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_2)
        )
    );
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<YR_EXTERNAL_VARIABLE__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_2),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_identifier_() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<YR_EXTERNAL_VARIABLE__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_EXTERNAL_VARIABLE__bindgen_ty_2),
                "::",
                stringify!(identifier_)
            )
        );
    }
    test_field_identifier_();
}
impl Default for YR_EXTERNAL_VARIABLE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_EXTERNAL_VARIABLE() {
    assert_eq!(
        ::std::mem::size_of::<YR_EXTERNAL_VARIABLE>(),
        24usize,
        concat!("Size of: ", stringify!(YR_EXTERNAL_VARIABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_EXTERNAL_VARIABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_EXTERNAL_VARIABLE))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_EXTERNAL_VARIABLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_EXTERNAL_VARIABLE),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_EXTERNAL_VARIABLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_EXTERNAL_VARIABLE),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
impl Default for YR_EXTERNAL_VARIABLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_AC_MATCH {
    pub __bindgen_anon_1: YR_AC_MATCH__bindgen_ty_1,
    pub __bindgen_anon_2: YR_AC_MATCH__bindgen_ty_2,
    pub __bindgen_anon_3: YR_AC_MATCH__bindgen_ty_3,
    pub __bindgen_anon_4: YR_AC_MATCH__bindgen_ty_4,
    pub backtrack: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_AC_MATCH__bindgen_ty_1 {
    pub string: *mut YR_STRING,
    pub string_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_AC_MATCH__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_MATCH__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(YR_AC_MATCH__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_MATCH__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_MATCH__bindgen_ty_1))
    );
    fn test_field_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_1),
                "::",
                stringify!(string)
            )
        );
    }
    test_field_string();
    fn test_field_string_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_1),
                "::",
                stringify!(string_)
            )
        );
    }
    test_field_string_();
}
impl Default for YR_AC_MATCH__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_AC_MATCH__bindgen_ty_2 {
    pub forward_code: *const u8,
    pub forward_code_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_AC_MATCH__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_MATCH__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(YR_AC_MATCH__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_MATCH__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_MATCH__bindgen_ty_2))
    );
    fn test_field_forward_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forward_code) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_2),
                "::",
                stringify!(forward_code)
            )
        );
    }
    test_field_forward_code();
    fn test_field_forward_code_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forward_code_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_2),
                "::",
                stringify!(forward_code_)
            )
        );
    }
    test_field_forward_code_();
}
impl Default for YR_AC_MATCH__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_AC_MATCH__bindgen_ty_3 {
    pub backward_code: *const u8,
    pub backward_code_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_AC_MATCH__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_MATCH__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(YR_AC_MATCH__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_MATCH__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_MATCH__bindgen_ty_3))
    );
    fn test_field_backward_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backward_code) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_3),
                "::",
                stringify!(backward_code)
            )
        );
    }
    test_field_backward_code();
    fn test_field_backward_code_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backward_code_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_3),
                "::",
                stringify!(backward_code_)
            )
        );
    }
    test_field_backward_code_();
}
impl Default for YR_AC_MATCH__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_AC_MATCH__bindgen_ty_4 {
    pub next: *mut YR_AC_MATCH,
    pub next_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout_YR_AC_MATCH__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_MATCH__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(YR_AC_MATCH__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_MATCH__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_MATCH__bindgen_ty_4))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_4),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_next_() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH__bindgen_ty_4),
                "::",
                stringify!(next_)
            )
        );
    }
    test_field_next_();
}
impl Default for YR_AC_MATCH__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_AC_MATCH() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_MATCH>(),
        40usize,
        concat!("Size of: ", stringify!(YR_AC_MATCH))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_MATCH>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_MATCH))
    );
    fn test_field_backtrack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backtrack) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH),
                "::",
                stringify!(backtrack)
            )
        );
    }
    test_field_backtrack();
}
impl Default for YR_AC_MATCH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RE_NODE {
    pub type_: ::std::os::raw::c_int,
    pub __bindgen_anon_1: RE_NODE__bindgen_ty_1,
    pub __bindgen_anon_2: RE_NODE__bindgen_ty_2,
    pub greedy: ::std::os::raw::c_int,
    pub re_class: *mut RE_CLASS,
    pub children_head: *mut RE_NODE,
    pub children_tail: *mut RE_NODE,
    pub prev_sibling: *mut RE_NODE,
    pub next_sibling: *mut RE_NODE,
    pub forward_code_ref: YR_ARENA_REF,
    pub backward_code_ref: YR_ARENA_REF,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RE_NODE__bindgen_ty_1 {
    pub value: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub start: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RE_NODE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RE_NODE__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RE_NODE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_NODE__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RE_NODE__bindgen_ty_1))
    );
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE__bindgen_ty_1),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE__bindgen_ty_1),
                "::",
                stringify!(start)
            )
        );
    }
    test_field_start();
}
impl Default for RE_NODE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RE_NODE__bindgen_ty_2 {
    pub mask: ::std::os::raw::c_int,
    pub end: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RE_NODE__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<RE_NODE__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(RE_NODE__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_NODE__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(RE_NODE__bindgen_ty_2))
    );
    fn test_field_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE__bindgen_ty_2),
                "::",
                stringify!(mask)
            )
        );
    }
    test_field_mask();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE__bindgen_ty_2),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
}
impl Default for RE_NODE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_RE_NODE() {
    assert_eq!(
        ::std::mem::size_of::<RE_NODE>(),
        72usize,
        concat!("Size of: ", stringify!(RE_NODE))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_NODE>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_NODE))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_greedy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).greedy) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(greedy)
            )
        );
    }
    test_field_greedy();
    fn test_field_re_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_class) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(re_class)
            )
        );
    }
    test_field_re_class();
    fn test_field_children_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children_head) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(children_head)
            )
        );
    }
    test_field_children_head();
    fn test_field_children_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children_tail) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(children_tail)
            )
        );
    }
    test_field_children_tail();
    fn test_field_prev_sibling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev_sibling) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(prev_sibling)
            )
        );
    }
    test_field_prev_sibling();
    fn test_field_next_sibling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_sibling) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(next_sibling)
            )
        );
    }
    test_field_next_sibling();
    fn test_field_forward_code_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forward_code_ref) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(forward_code_ref)
            )
        );
    }
    test_field_forward_code_ref();
    fn test_field_backward_code_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backward_code_ref) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_NODE),
                "::",
                stringify!(backward_code_ref)
            )
        );
    }
    test_field_backward_code_ref();
}
impl Default for RE_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RE_CLASS {
    pub negated: u8,
    pub bitmap: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_RE_CLASS() {
    assert_eq!(
        ::std::mem::size_of::<RE_CLASS>(),
        33usize,
        concat!("Size of: ", stringify!(RE_CLASS))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_CLASS>(),
        1usize,
        concat!("Alignment of ", stringify!(RE_CLASS))
    );
    fn test_field_negated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_CLASS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).negated) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_CLASS),
                "::",
                stringify!(negated)
            )
        );
    }
    test_field_negated();
    fn test_field_bitmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_CLASS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bitmap) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_CLASS),
                "::",
                stringify!(bitmap)
            )
        );
    }
    test_field_bitmap();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE_AST {
    pub flags: u32,
    pub root_node: *mut RE_NODE,
}
#[test]
fn bindgen_test_layout_RE_AST() {
    assert_eq!(
        ::std::mem::size_of::<RE_AST>(),
        16usize,
        concat!("Size of: ", stringify!(RE_AST))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_AST>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_AST))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_AST>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_AST),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_root_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_AST>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_node) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_AST),
                "::",
                stringify!(root_node)
            )
        );
    }
    test_field_root_node();
}
impl Default for RE_AST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct RE {
    pub flags: u32,
    pub code: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_RE() {
    assert_eq!(
        ::std::mem::size_of::<RE>(),
        4usize,
        concat!("Size of: ", stringify!(RE))
    );
    assert_eq!(
        ::std::mem::align_of::<RE>(),
        1usize,
        concat!("Alignment of ", stringify!(RE))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RE), "::", stringify!(flags))
        );
    }
    test_field_flags();
    fn test_field_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(RE), "::", stringify!(code))
        );
    }
    test_field_code();
}
impl Default for RE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE_ERROR {
    pub message: [::std::os::raw::c_char; 384usize],
}
#[test]
fn bindgen_test_layout_RE_ERROR() {
    assert_eq!(
        ::std::mem::size_of::<RE_ERROR>(),
        384usize,
        concat!("Size of: ", stringify!(RE_ERROR))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_ERROR>(),
        1usize,
        concat!("Alignment of ", stringify!(RE_ERROR))
    );
    fn test_field_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_ERROR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_ERROR),
                "::",
                stringify!(message)
            )
        );
    }
    test_field_message();
}
impl Default for RE_ERROR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE_FIBER {
    pub ip: *const u8,
    pub sp: i32,
    pub rc: i32,
    pub prev: *mut RE_FIBER,
    pub next: *mut RE_FIBER,
    pub stack: [u16; 1024usize],
}
#[test]
fn bindgen_test_layout_RE_FIBER() {
    assert_eq!(
        ::std::mem::size_of::<RE_FIBER>(),
        2080usize,
        concat!("Size of: ", stringify!(RE_FIBER))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_FIBER>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_FIBER))
    );
    fn test_field_ip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER),
                "::",
                stringify!(ip)
            )
        );
    }
    test_field_ip();
    fn test_field_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER),
                "::",
                stringify!(sp)
            )
        );
    }
    test_field_sp();
    fn test_field_rc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rc) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER),
                "::",
                stringify!(rc)
            )
        );
    }
    test_field_rc();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER),
                "::",
                stringify!(stack)
            )
        );
    }
    test_field_stack();
}
impl Default for RE_FIBER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE_FIBER_LIST {
    pub head: *mut RE_FIBER,
    pub tail: *mut RE_FIBER,
}
#[test]
fn bindgen_test_layout_RE_FIBER_LIST() {
    assert_eq!(
        ::std::mem::size_of::<RE_FIBER_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(RE_FIBER_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_FIBER_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_FIBER_LIST))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER_LIST>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER_LIST),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER_LIST>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER_LIST),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
}
impl Default for RE_FIBER_LIST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE_FIBER_POOL {
    pub fiber_count: ::std::os::raw::c_int,
    pub fibers: RE_FIBER_LIST,
}
#[test]
fn bindgen_test_layout_RE_FIBER_POOL() {
    assert_eq!(
        ::std::mem::size_of::<RE_FIBER_POOL>(),
        24usize,
        concat!("Size of: ", stringify!(RE_FIBER_POOL))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_FIBER_POOL>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_FIBER_POOL))
    );
    fn test_field_fiber_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER_POOL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fiber_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER_POOL),
                "::",
                stringify!(fiber_count)
            )
        );
    }
    test_field_fiber_count();
    fn test_field_fibers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FIBER_POOL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fibers) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FIBER_POOL),
                "::",
                stringify!(fibers)
            )
        );
    }
    test_field_fibers();
}
impl Default for RE_FIBER_POOL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE_FAST_EXEC_POSITION {
    pub round: ::std::os::raw::c_int,
    pub input: *const u8,
    pub prev: *mut RE_FAST_EXEC_POSITION,
    pub next: *mut RE_FAST_EXEC_POSITION,
}
#[test]
fn bindgen_test_layout_RE_FAST_EXEC_POSITION() {
    assert_eq!(
        ::std::mem::size_of::<RE_FAST_EXEC_POSITION>(),
        32usize,
        concat!("Size of: ", stringify!(RE_FAST_EXEC_POSITION))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_FAST_EXEC_POSITION>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_FAST_EXEC_POSITION))
    );
    fn test_field_round() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FAST_EXEC_POSITION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).round) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FAST_EXEC_POSITION),
                "::",
                stringify!(round)
            )
        );
    }
    test_field_round();
    fn test_field_input() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FAST_EXEC_POSITION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FAST_EXEC_POSITION),
                "::",
                stringify!(input)
            )
        );
    }
    test_field_input();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FAST_EXEC_POSITION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FAST_EXEC_POSITION),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FAST_EXEC_POSITION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FAST_EXEC_POSITION),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
impl Default for RE_FAST_EXEC_POSITION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RE_FAST_EXEC_POSITION_POOL {
    pub head: *mut RE_FAST_EXEC_POSITION,
}
#[test]
fn bindgen_test_layout_RE_FAST_EXEC_POSITION_POOL() {
    assert_eq!(
        ::std::mem::size_of::<RE_FAST_EXEC_POSITION_POOL>(),
        8usize,
        concat!("Size of: ", stringify!(RE_FAST_EXEC_POSITION_POOL))
    );
    assert_eq!(
        ::std::mem::align_of::<RE_FAST_EXEC_POSITION_POOL>(),
        8usize,
        concat!("Alignment of ", stringify!(RE_FAST_EXEC_POSITION_POOL))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RE_FAST_EXEC_POSITION_POOL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RE_FAST_EXEC_POSITION_POOL),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
}
impl Default for RE_FAST_EXEC_POSITION_POOL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_MODIFIER {
    pub flags: i32,
    pub xor_min: u8,
    pub xor_max: u8,
    pub alphabet: *mut SIZED_STRING,
}
#[test]
fn bindgen_test_layout_YR_MODIFIER() {
    assert_eq!(
        ::std::mem::size_of::<YR_MODIFIER>(),
        16usize,
        concat!("Size of: ", stringify!(YR_MODIFIER))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_MODIFIER>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_MODIFIER))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODIFIER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODIFIER),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_xor_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODIFIER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xor_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODIFIER),
                "::",
                stringify!(xor_min)
            )
        );
    }
    test_field_xor_min();
    fn test_field_xor_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODIFIER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xor_max) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODIFIER),
                "::",
                stringify!(xor_max)
            )
        );
    }
    test_field_xor_max();
    fn test_field_alphabet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODIFIER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphabet) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODIFIER),
                "::",
                stringify!(alphabet)
            )
        );
    }
    test_field_alphabet();
}
impl Default for YR_MODIFIER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_MATCHES {
    pub head: *mut YR_MATCH,
    pub tail: *mut YR_MATCH,
    pub count: i32,
}
#[test]
fn bindgen_test_layout_YR_MATCHES() {
    assert_eq!(
        ::std::mem::size_of::<YR_MATCHES>(),
        24usize,
        concat!("Size of: ", stringify!(YR_MATCHES))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_MATCHES>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_MATCHES))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCHES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCHES),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCHES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCHES),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCHES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCHES),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
}
impl Default for YR_MATCHES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_MATCH {
    pub base: i64,
    pub offset: i64,
    pub match_length: i32,
    pub data_length: i32,
    pub data: *const u8,
    pub prev: *mut YR_MATCH,
    pub next: *mut YR_MATCH,
    pub chain_length: i32,
    pub is_private: bool,
    pub xor_key: u8,
}
#[test]
fn bindgen_test_layout_YR_MATCH() {
    assert_eq!(
        ::std::mem::size_of::<YR_MATCH>(),
        56usize,
        concat!("Size of: ", stringify!(YR_MATCH))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_MATCH>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_MATCH))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_match_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).match_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(match_length)
            )
        );
    }
    test_field_match_length();
    fn test_field_data_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_length) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(data_length)
            )
        );
    }
    test_field_data_length();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_chain_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chain_length) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(chain_length)
            )
        );
    }
    test_field_chain_length();
    fn test_field_is_private() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_private) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(is_private)
            )
        );
    }
    test_field_is_private();
    fn test_field_xor_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MATCH>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xor_key) as usize - ptr as usize
            },
            53usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MATCH),
                "::",
                stringify!(xor_key)
            )
        );
    }
    test_field_xor_key();
}
impl Default for YR_MATCH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_AC_STATE {
    pub failure: *mut YR_AC_STATE,
    pub first_child: *mut YR_AC_STATE,
    pub siblings: *mut YR_AC_STATE,
    pub matches_ref: YR_ARENA_REF,
    pub depth: u8,
    pub input: u8,
    pub t_table_slot: u32,
}
#[test]
fn bindgen_test_layout_YR_AC_STATE() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_STATE>(),
        40usize,
        concat!("Size of: ", stringify!(YR_AC_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_STATE))
    );
    fn test_field_failure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_STATE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).failure) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_STATE),
                "::",
                stringify!(failure)
            )
        );
    }
    test_field_failure();
    fn test_field_first_child() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_STATE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).first_child) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_STATE),
                "::",
                stringify!(first_child)
            )
        );
    }
    test_field_first_child();
    fn test_field_siblings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_STATE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).siblings) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_STATE),
                "::",
                stringify!(siblings)
            )
        );
    }
    test_field_siblings();
    fn test_field_matches_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_STATE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).matches_ref) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_STATE),
                "::",
                stringify!(matches_ref)
            )
        );
    }
    test_field_matches_ref();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_STATE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_STATE),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_input() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_STATE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_STATE),
                "::",
                stringify!(input)
            )
        );
    }
    test_field_input();
    fn test_field_t_table_slot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_STATE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).t_table_slot) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_STATE),
                "::",
                stringify!(t_table_slot)
            )
        );
    }
    test_field_t_table_slot();
}
impl Default for YR_AC_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_AC_MATCH_LIST_ENTRY {
    pub backtrack: u16,
    pub string_idx: u32,
    pub ref_: YR_ARENA_REF,
    pub forward_code_ref: YR_ARENA_REF,
    pub backward_code_ref: YR_ARENA_REF,
    pub next: *mut YR_AC_MATCH_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout_YR_AC_MATCH_LIST_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_MATCH_LIST_ENTRY>(),
        40usize,
        concat!("Size of: ", stringify!(YR_AC_MATCH_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_MATCH_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_MATCH_LIST_ENTRY))
    );
    fn test_field_backtrack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backtrack) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH_LIST_ENTRY),
                "::",
                stringify!(backtrack)
            )
        );
    }
    test_field_backtrack();
    fn test_field_string_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_idx) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH_LIST_ENTRY),
                "::",
                stringify!(string_idx)
            )
        );
    }
    test_field_string_idx();
    fn test_field_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH_LIST_ENTRY),
                "::",
                stringify!(ref_)
            )
        );
    }
    test_field_ref();
    fn test_field_forward_code_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forward_code_ref) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH_LIST_ENTRY),
                "::",
                stringify!(forward_code_ref)
            )
        );
    }
    test_field_forward_code_ref();
    fn test_field_backward_code_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backward_code_ref) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH_LIST_ENTRY),
                "::",
                stringify!(backward_code_ref)
            )
        );
    }
    test_field_backward_code_ref();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_MATCH_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_MATCH_LIST_ENTRY),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
impl Default for YR_AC_MATCH_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_AC_AUTOMATON {
    pub arena: *mut YR_ARENA,
    pub tables_size: u32,
    pub t_table_unused_candidate: u32,
    pub bitmask: *mut ::std::os::raw::c_ulong,
    pub root: *mut YR_AC_STATE,
}
#[test]
fn bindgen_test_layout_YR_AC_AUTOMATON() {
    assert_eq!(
        ::std::mem::size_of::<YR_AC_AUTOMATON>(),
        32usize,
        concat!("Size of: ", stringify!(YR_AC_AUTOMATON))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_AC_AUTOMATON>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_AC_AUTOMATON))
    );
    fn test_field_arena() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_AUTOMATON>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_AUTOMATON),
                "::",
                stringify!(arena)
            )
        );
    }
    test_field_arena();
    fn test_field_tables_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_AUTOMATON>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tables_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_AUTOMATON),
                "::",
                stringify!(tables_size)
            )
        );
    }
    test_field_tables_size();
    fn test_field_t_table_unused_candidate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_AUTOMATON>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).t_table_unused_candidate) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_AUTOMATON),
                "::",
                stringify!(t_table_unused_candidate)
            )
        );
    }
    test_field_t_table_unused_candidate();
    fn test_field_bitmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_AUTOMATON>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bitmask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_AUTOMATON),
                "::",
                stringify!(bitmask)
            )
        );
    }
    test_field_bitmask();
    fn test_field_root() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_AC_AUTOMATON>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_AC_AUTOMATON),
                "::",
                stringify!(root)
            )
        );
    }
    test_field_root();
}
impl Default for YR_AC_AUTOMATON {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_RULES {
    pub arena: *mut YR_ARENA,
    pub __bindgen_anon_1: YR_RULES__bindgen_ty_1,
    pub __bindgen_anon_2: YR_RULES__bindgen_ty_2,
    pub __bindgen_anon_3: YR_RULES__bindgen_ty_3,
    pub ac_transition_table: *mut YR_AC_TRANSITION,
    pub ac_match_pool: *mut YR_AC_MATCH,
    pub ac_match_table: *mut u32,
    pub code_start: *const u8,
    pub num_rules: u32,
    pub num_strings: u32,
    pub num_namespaces: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULES__bindgen_ty_1 {
    pub rules_table: *mut YR_RULE,
    pub rules_list_head: *mut YR_RULE,
}
#[test]
fn bindgen_test_layout_YR_RULES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULES__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULES__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULES__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULES__bindgen_ty_1))
    );
    fn test_field_rules_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rules_table) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES__bindgen_ty_1),
                "::",
                stringify!(rules_table)
            )
        );
    }
    test_field_rules_table();
    fn test_field_rules_list_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rules_list_head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES__bindgen_ty_1),
                "::",
                stringify!(rules_list_head)
            )
        );
    }
    test_field_rules_list_head();
}
impl Default for YR_RULES__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULES__bindgen_ty_2 {
    pub strings_table: *mut YR_STRING,
    pub strings_list_head: *mut YR_STRING,
}
#[test]
fn bindgen_test_layout_YR_RULES__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULES__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULES__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULES__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULES__bindgen_ty_2))
    );
    fn test_field_strings_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings_table) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES__bindgen_ty_2),
                "::",
                stringify!(strings_table)
            )
        );
    }
    test_field_strings_table();
    fn test_field_strings_list_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings_list_head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES__bindgen_ty_2),
                "::",
                stringify!(strings_list_head)
            )
        );
    }
    test_field_strings_list_head();
}
impl Default for YR_RULES__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_RULES__bindgen_ty_3 {
    pub ext_vars_table: *mut YR_EXTERNAL_VARIABLE,
    pub externals_list_head: *mut YR_EXTERNAL_VARIABLE,
}
#[test]
fn bindgen_test_layout_YR_RULES__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULES__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(YR_RULES__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULES__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULES__bindgen_ty_3))
    );
    fn test_field_ext_vars_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ext_vars_table) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES__bindgen_ty_3),
                "::",
                stringify!(ext_vars_table)
            )
        );
    }
    test_field_ext_vars_table();
    fn test_field_externals_list_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externals_list_head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES__bindgen_ty_3),
                "::",
                stringify!(externals_list_head)
            )
        );
    }
    test_field_externals_list_head();
}
impl Default for YR_RULES__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_RULES() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULES>(),
        80usize,
        concat!("Size of: ", stringify!(YR_RULES))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULES>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULES))
    );
    fn test_field_arena() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(arena)
            )
        );
    }
    test_field_arena();
    fn test_field_ac_transition_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_transition_table) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(ac_transition_table)
            )
        );
    }
    test_field_ac_transition_table();
    fn test_field_ac_match_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_match_pool) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(ac_match_pool)
            )
        );
    }
    test_field_ac_match_pool();
    fn test_field_ac_match_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_match_table) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(ac_match_table)
            )
        );
    }
    test_field_ac_match_table();
    fn test_field_code_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code_start) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(code_start)
            )
        );
    }
    test_field_code_start();
    fn test_field_num_rules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_rules) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(num_rules)
            )
        );
    }
    test_field_num_rules();
    fn test_field_num_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_strings) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(num_strings)
            )
        );
    }
    test_field_num_strings();
    fn test_field_num_namespaces() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_namespaces) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES),
                "::",
                stringify!(num_namespaces)
            )
        );
    }
    test_field_num_namespaces();
}
impl Default for YR_RULES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_RULES_STATS {
    pub num_rules: u32,
    pub num_strings: u32,
    pub ac_matches: u32,
    pub ac_root_match_list_length: u32,
    pub ac_average_match_list_length: f32,
    pub top_ac_match_list_lengths: [u32; 100usize],
    pub ac_match_list_length_pctls: [u32; 101usize],
    pub ac_tables_size: u32,
}
#[test]
fn bindgen_test_layout_YR_RULES_STATS() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULES_STATS>(),
        828usize,
        concat!("Size of: ", stringify!(YR_RULES_STATS))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULES_STATS>(),
        4usize,
        concat!("Alignment of ", stringify!(YR_RULES_STATS))
    );
    fn test_field_num_rules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_rules) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(num_rules)
            )
        );
    }
    test_field_num_rules();
    fn test_field_num_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_strings) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(num_strings)
            )
        );
    }
    test_field_num_strings();
    fn test_field_ac_matches() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_matches) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(ac_matches)
            )
        );
    }
    test_field_ac_matches();
    fn test_field_ac_root_match_list_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_root_match_list_length) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(ac_root_match_list_length)
            )
        );
    }
    test_field_ac_root_match_list_length();
    fn test_field_ac_average_match_list_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_average_match_list_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(ac_average_match_list_length)
            )
        );
    }
    test_field_ac_average_match_list_length();
    fn test_field_top_ac_match_list_lengths() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top_ac_match_list_lengths) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(top_ac_match_list_lengths)
            )
        );
    }
    test_field_top_ac_match_list_lengths();
    fn test_field_ac_match_list_length_pctls() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_match_list_length_pctls) as usize - ptr as usize
            },
            420usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(ac_match_list_length_pctls)
            )
        );
    }
    test_field_ac_match_list_length_pctls();
    fn test_field_ac_tables_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULES_STATS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_tables_size) as usize - ptr as usize
            },
            824usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULES_STATS),
                "::",
                stringify!(ac_tables_size)
            )
        );
    }
    test_field_ac_tables_size();
}
impl Default for YR_RULES_STATS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct YR_PROFILING_INFO {
    pub atom_matches: u32,
    pub match_time: u64,
    pub exec_time: u64,
}
#[test]
fn bindgen_test_layout_YR_PROFILING_INFO() {
    assert_eq!(
        ::std::mem::size_of::<YR_PROFILING_INFO>(),
        24usize,
        concat!("Size of: ", stringify!(YR_PROFILING_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_PROFILING_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_PROFILING_INFO))
    );
    fn test_field_atom_matches() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_PROFILING_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atom_matches) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_PROFILING_INFO),
                "::",
                stringify!(atom_matches)
            )
        );
    }
    test_field_atom_matches();
    fn test_field_match_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_PROFILING_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).match_time) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_PROFILING_INFO),
                "::",
                stringify!(match_time)
            )
        );
    }
    test_field_match_time();
    fn test_field_exec_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_PROFILING_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exec_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_PROFILING_INFO),
                "::",
                stringify!(exec_time)
            )
        );
    }
    test_field_exec_time();
}
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_RULE_PROFILING_INFO {
    pub rule: *mut YR_RULE,
    pub cost: u64,
}
#[test]
fn bindgen_test_layout_YR_RULE_PROFILING_INFO() {
    assert_eq!(
        ::std::mem::size_of::<YR_RULE_PROFILING_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(YR_RULE_PROFILING_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_RULE_PROFILING_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_RULE_PROFILING_INFO))
    );
    fn test_field_rule() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE_PROFILING_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rule) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE_PROFILING_INFO),
                "::",
                stringify!(rule)
            )
        );
    }
    test_field_rule();
    fn test_field_cost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_RULE_PROFILING_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cost) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_RULE_PROFILING_INFO),
                "::",
                stringify!(cost)
            )
        );
    }
    test_field_cost();
}
impl Default for YR_RULE_PROFILING_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_MEMORY_BLOCK_FETCH_DATA_FUNC =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut YR_MEMORY_BLOCK) -> *const u8>;
pub type YR_MEMORY_BLOCK_ITERATOR_FUNC = ::std::option::Option<
    unsafe extern "C" fn(self_: *mut YR_MEMORY_BLOCK_ITERATOR) -> *mut YR_MEMORY_BLOCK,
>;
pub type YR_MEMORY_BLOCK_ITERATOR_SIZE_FUNC =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut YR_MEMORY_BLOCK_ITERATOR) -> u64>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_MEMORY_BLOCK {
    pub size: size_t,
    pub base: u64,
    pub context: *mut ::std::os::raw::c_void,
    pub fetch_data: YR_MEMORY_BLOCK_FETCH_DATA_FUNC,
}
#[test]
fn bindgen_test_layout_YR_MEMORY_BLOCK() {
    assert_eq!(
        ::std::mem::size_of::<YR_MEMORY_BLOCK>(),
        32usize,
        concat!("Size of: ", stringify!(YR_MEMORY_BLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_MEMORY_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_MEMORY_BLOCK))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_fetch_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fetch_data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK),
                "::",
                stringify!(fetch_data)
            )
        );
    }
    test_field_fetch_data();
}
impl Default for YR_MEMORY_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_MEMORY_BLOCK_ITERATOR {
    pub context: *mut ::std::os::raw::c_void,
    pub first: YR_MEMORY_BLOCK_ITERATOR_FUNC,
    pub next: YR_MEMORY_BLOCK_ITERATOR_FUNC,
    pub file_size: YR_MEMORY_BLOCK_ITERATOR_SIZE_FUNC,
    pub last_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_YR_MEMORY_BLOCK_ITERATOR() {
    assert_eq!(
        ::std::mem::size_of::<YR_MEMORY_BLOCK_ITERATOR>(),
        40usize,
        concat!("Size of: ", stringify!(YR_MEMORY_BLOCK_ITERATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_MEMORY_BLOCK_ITERATOR>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_MEMORY_BLOCK_ITERATOR))
    );
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK_ITERATOR),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_first() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).first) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK_ITERATOR),
                "::",
                stringify!(first)
            )
        );
    }
    test_field_first();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK_ITERATOR),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_file_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK_ITERATOR),
                "::",
                stringify!(file_size)
            )
        );
    }
    test_field_file_size();
    fn test_field_last_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MEMORY_BLOCK_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_error) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MEMORY_BLOCK_ITERATOR),
                "::",
                stringify!(last_error)
            )
        );
    }
    test_field_last_error();
}
impl Default for YR_MEMORY_BLOCK_ITERATOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_CALLBACK_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut YR_SCAN_CONTEXT,
        message: ::std::os::raw::c_int,
        message_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_SCAN_CONTEXT {
    pub file_size: u64,
    pub entry_point: u64,
    pub flags: ::std::os::raw::c_int,
    pub canary: ::std::os::raw::c_int,
    pub timeout: u64,
    pub user_data: *mut ::std::os::raw::c_void,
    pub callback: YR_CALLBACK_FUNC,
    pub rules: *mut YR_RULES,
    pub last_error_string: *mut YR_STRING,
    pub iterator: *mut YR_MEMORY_BLOCK_ITERATOR,
    pub objects_table: *mut YR_HASH_TABLE,
    pub matches_notebook: *mut YR_NOTEBOOK,
    pub stopwatch: YR_STOPWATCH,
    pub re_fiber_pool: RE_FIBER_POOL,
    pub re_fast_exec_position_pool: RE_FAST_EXEC_POSITION_POOL,
    pub rule_matches_flags: *mut ::std::os::raw::c_ulong,
    pub ns_unsatisfied_flags: *mut ::std::os::raw::c_ulong,
    pub strings_temp_disabled: *mut ::std::os::raw::c_ulong,
    pub matches: *mut YR_MATCHES,
    pub unconfirmed_matches: *mut YR_MATCHES,
    pub profiling_info: *mut YR_PROFILING_INFO,
}
#[test]
fn bindgen_test_layout_YR_SCAN_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<YR_SCAN_CONTEXT>(),
        184usize,
        concat!("Size of: ", stringify!(YR_SCAN_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_SCAN_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_SCAN_CONTEXT))
    );
    fn test_field_file_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(file_size)
            )
        );
    }
    test_field_file_size();
    fn test_field_entry_point() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_point) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(entry_point)
            )
        );
    }
    test_field_entry_point();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_canary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canary) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(canary)
            )
        );
    }
    test_field_canary();
    fn test_field_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(timeout)
            )
        );
    }
    test_field_timeout();
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
    fn test_field_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(callback)
            )
        );
    }
    test_field_callback();
    fn test_field_rules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rules) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(rules)
            )
        );
    }
    test_field_rules();
    fn test_field_last_error_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_error_string) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(last_error_string)
            )
        );
    }
    test_field_last_error_string();
    fn test_field_iterator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iterator) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(iterator)
            )
        );
    }
    test_field_iterator();
    fn test_field_objects_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objects_table) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(objects_table)
            )
        );
    }
    test_field_objects_table();
    fn test_field_matches_notebook() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).matches_notebook) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(matches_notebook)
            )
        );
    }
    test_field_matches_notebook();
    fn test_field_stopwatch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stopwatch) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(stopwatch)
            )
        );
    }
    test_field_stopwatch();
    fn test_field_re_fiber_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_fiber_pool) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(re_fiber_pool)
            )
        );
    }
    test_field_re_fiber_pool();
    fn test_field_re_fast_exec_position_pool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_fast_exec_position_pool) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(re_fast_exec_position_pool)
            )
        );
    }
    test_field_re_fast_exec_position_pool();
    fn test_field_rule_matches_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rule_matches_flags) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(rule_matches_flags)
            )
        );
    }
    test_field_rule_matches_flags();
    fn test_field_ns_unsatisfied_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns_unsatisfied_flags) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(ns_unsatisfied_flags)
            )
        );
    }
    test_field_ns_unsatisfied_flags();
    fn test_field_strings_temp_disabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings_temp_disabled) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(strings_temp_disabled)
            )
        );
    }
    test_field_strings_temp_disabled();
    fn test_field_matches() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).matches) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(matches)
            )
        );
    }
    test_field_matches();
    fn test_field_unconfirmed_matches() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unconfirmed_matches) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(unconfirmed_matches)
            )
        );
    }
    test_field_unconfirmed_matches();
    fn test_field_profiling_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_SCAN_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).profiling_info) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_SCAN_CONTEXT),
                "::",
                stringify!(profiling_info)
            )
        );
    }
    test_field_profiling_info();
}
impl Default for YR_SCAN_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_VALUE {
    pub i: i64,
    pub d: f64,
    pub p: *mut ::std::os::raw::c_void,
    pub o: *mut YR_OBJECT,
    pub s: *mut YR_STRING,
    pub it: *mut YR_ITERATOR,
    pub ss: *mut SIZED_STRING,
    pub re: *mut RE,
}
#[test]
fn bindgen_test_layout_YR_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<YR_VALUE>(),
        8usize,
        concat!("Size of: ", stringify!(YR_VALUE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_VALUE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_VALUE))
    );
    fn test_field_i() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(i)
            )
        );
    }
    test_field_i();
    fn test_field_d() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(d)
            )
        );
    }
    test_field_d();
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_o() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).o) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(o)
            )
        );
    }
    test_field_o();
    fn test_field_s() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(s)
            )
        );
    }
    test_field_s();
    fn test_field_it() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(it)
            )
        );
    }
    test_field_it();
    fn test_field_ss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(ss)
            )
        );
    }
    test_field_ss();
    fn test_field_re() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE),
                "::",
                stringify!(re)
            )
        );
    }
    test_field_re();
}
impl Default for YR_VALUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_VALUE_STACK {
    pub sp: u32,
    pub capacity: u32,
    pub items: *mut YR_VALUE,
}
#[test]
fn bindgen_test_layout_YR_VALUE_STACK() {
    assert_eq!(
        ::std::mem::size_of::<YR_VALUE_STACK>(),
        16usize,
        concat!("Size of: ", stringify!(YR_VALUE_STACK))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_VALUE_STACK>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_VALUE_STACK))
    );
    fn test_field_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE_STACK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE_STACK),
                "::",
                stringify!(sp)
            )
        );
    }
    test_field_sp();
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE_STACK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE_STACK),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
    fn test_field_items() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_VALUE_STACK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_VALUE_STACK),
                "::",
                stringify!(items)
            )
        );
    }
    test_field_items();
}
impl Default for YR_VALUE_STACK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_OBJECT {
    pub canary: ::std::os::raw::c_int,
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub parent: *mut YR_OBJECT,
    pub data: *mut ::std::os::raw::c_void,
    pub value: YR_VALUE,
}
#[test]
fn bindgen_test_layout_YR_OBJECT() {
    assert_eq!(
        ::std::mem::size_of::<YR_OBJECT>(),
        40usize,
        concat!("Size of: ", stringify!(YR_OBJECT))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_OBJECT))
    );
    fn test_field_canary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT),
                "::",
                stringify!(canary)
            )
        );
    }
    test_field_canary();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
impl Default for YR_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_OBJECT_STRUCTURE {
    pub canary: ::std::os::raw::c_int,
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub parent: *mut YR_OBJECT,
    pub data: *mut ::std::os::raw::c_void,
    pub members: *mut YR_STRUCTURE_MEMBER,
}
#[test]
fn bindgen_test_layout_YR_OBJECT_STRUCTURE() {
    assert_eq!(
        ::std::mem::size_of::<YR_OBJECT_STRUCTURE>(),
        40usize,
        concat!("Size of: ", stringify!(YR_OBJECT_STRUCTURE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_OBJECT_STRUCTURE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_OBJECT_STRUCTURE))
    );
    fn test_field_canary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_STRUCTURE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_STRUCTURE),
                "::",
                stringify!(canary)
            )
        );
    }
    test_field_canary();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_STRUCTURE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_STRUCTURE),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_STRUCTURE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_STRUCTURE),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_STRUCTURE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_STRUCTURE),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_STRUCTURE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_STRUCTURE),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_members() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_STRUCTURE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).members) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_STRUCTURE),
                "::",
                stringify!(members)
            )
        );
    }
    test_field_members();
}
impl Default for YR_OBJECT_STRUCTURE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_OBJECT_ARRAY {
    pub canary: ::std::os::raw::c_int,
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub parent: *mut YR_OBJECT,
    pub data: *mut ::std::os::raw::c_void,
    pub prototype_item: *mut YR_OBJECT,
    pub items: *mut YR_ARRAY_ITEMS,
}
#[test]
fn bindgen_test_layout_YR_OBJECT_ARRAY() {
    assert_eq!(
        ::std::mem::size_of::<YR_OBJECT_ARRAY>(),
        48usize,
        concat!("Size of: ", stringify!(YR_OBJECT_ARRAY))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_OBJECT_ARRAY>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_OBJECT_ARRAY))
    );
    fn test_field_canary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_ARRAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_ARRAY),
                "::",
                stringify!(canary)
            )
        );
    }
    test_field_canary();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_ARRAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_ARRAY),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_ARRAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_ARRAY),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_ARRAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_ARRAY),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_ARRAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_ARRAY),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_prototype_item() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_ARRAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prototype_item) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_ARRAY),
                "::",
                stringify!(prototype_item)
            )
        );
    }
    test_field_prototype_item();
    fn test_field_items() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_ARRAY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_ARRAY),
                "::",
                stringify!(items)
            )
        );
    }
    test_field_items();
}
impl Default for YR_OBJECT_ARRAY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_OBJECT_DICTIONARY {
    pub canary: ::std::os::raw::c_int,
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub parent: *mut YR_OBJECT,
    pub data: *mut ::std::os::raw::c_void,
    pub prototype_item: *mut YR_OBJECT,
    pub items: *mut YR_DICTIONARY_ITEMS,
}
#[test]
fn bindgen_test_layout_YR_OBJECT_DICTIONARY() {
    assert_eq!(
        ::std::mem::size_of::<YR_OBJECT_DICTIONARY>(),
        48usize,
        concat!("Size of: ", stringify!(YR_OBJECT_DICTIONARY))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_OBJECT_DICTIONARY>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_OBJECT_DICTIONARY))
    );
    fn test_field_canary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_DICTIONARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_DICTIONARY),
                "::",
                stringify!(canary)
            )
        );
    }
    test_field_canary();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_DICTIONARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_DICTIONARY),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_DICTIONARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_DICTIONARY),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_DICTIONARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_DICTIONARY),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_DICTIONARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_DICTIONARY),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_prototype_item() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_DICTIONARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prototype_item) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_DICTIONARY),
                "::",
                stringify!(prototype_item)
            )
        );
    }
    test_field_prototype_item();
    fn test_field_items() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_DICTIONARY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_DICTIONARY),
                "::",
                stringify!(items)
            )
        );
    }
    test_field_items();
}
impl Default for YR_OBJECT_DICTIONARY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_MODULE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        args: *mut YR_VALUE,
        context: *mut YR_SCAN_CONTEXT,
        function_obj: *mut YR_OBJECT_FUNCTION,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_OBJECT_FUNCTION {
    pub canary: ::std::os::raw::c_int,
    pub type_: i8,
    pub identifier: *const ::std::os::raw::c_char,
    pub parent: *mut YR_OBJECT,
    pub data: *mut ::std::os::raw::c_void,
    pub return_obj: *mut YR_OBJECT,
    pub prototypes: [YR_OBJECT_FUNCTION__bindgen_ty_1; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_OBJECT_FUNCTION__bindgen_ty_1 {
    pub arguments_fmt: *const ::std::os::raw::c_char,
    pub code: YR_MODULE_FUNC,
}
#[test]
fn bindgen_test_layout_YR_OBJECT_FUNCTION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_OBJECT_FUNCTION__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(YR_OBJECT_FUNCTION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_OBJECT_FUNCTION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(YR_OBJECT_FUNCTION__bindgen_ty_1)
        )
    );
    fn test_field_arguments_fmt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arguments_fmt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION__bindgen_ty_1),
                "::",
                stringify!(arguments_fmt)
            )
        );
    }
    test_field_arguments_fmt();
    fn test_field_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION__bindgen_ty_1),
                "::",
                stringify!(code)
            )
        );
    }
    test_field_code();
}
impl Default for YR_OBJECT_FUNCTION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_OBJECT_FUNCTION() {
    assert_eq!(
        ::std::mem::size_of::<YR_OBJECT_FUNCTION>(),
        200usize,
        concat!("Size of: ", stringify!(YR_OBJECT_FUNCTION))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_OBJECT_FUNCTION>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_OBJECT_FUNCTION))
    );
    fn test_field_canary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).canary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION),
                "::",
                stringify!(canary)
            )
        );
    }
    test_field_canary();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_return_obj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).return_obj) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION),
                "::",
                stringify!(return_obj)
            )
        );
    }
    test_field_return_obj();
    fn test_field_prototypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_OBJECT_FUNCTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prototypes) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_OBJECT_FUNCTION),
                "::",
                stringify!(prototypes)
            )
        );
    }
    test_field_prototypes();
}
impl Default for YR_OBJECT_FUNCTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_STRUCTURE_MEMBER {
    pub object: *mut YR_OBJECT,
    pub next: *mut YR_STRUCTURE_MEMBER,
}
#[test]
fn bindgen_test_layout_YR_STRUCTURE_MEMBER() {
    assert_eq!(
        ::std::mem::size_of::<YR_STRUCTURE_MEMBER>(),
        16usize,
        concat!("Size of: ", stringify!(YR_STRUCTURE_MEMBER))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_STRUCTURE_MEMBER>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_STRUCTURE_MEMBER))
    );
    fn test_field_object() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRUCTURE_MEMBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRUCTURE_MEMBER),
                "::",
                stringify!(object)
            )
        );
    }
    test_field_object();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRUCTURE_MEMBER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRUCTURE_MEMBER),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
impl Default for YR_STRUCTURE_MEMBER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ARRAY_ITEMS {
    pub capacity: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub objects: [*mut YR_OBJECT; 1usize],
}
#[test]
fn bindgen_test_layout_YR_ARRAY_ITEMS() {
    assert_eq!(
        ::std::mem::size_of::<YR_ARRAY_ITEMS>(),
        16usize,
        concat!("Size of: ", stringify!(YR_ARRAY_ITEMS))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ARRAY_ITEMS>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ARRAY_ITEMS))
    );
    fn test_field_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARRAY_ITEMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARRAY_ITEMS),
                "::",
                stringify!(capacity)
            )
        );
    }
    test_field_capacity();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARRAY_ITEMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARRAY_ITEMS),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_objects() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARRAY_ITEMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objects) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARRAY_ITEMS),
                "::",
                stringify!(objects)
            )
        );
    }
    test_field_objects();
}
impl Default for YR_ARRAY_ITEMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_DICTIONARY_ITEMS {
    pub used: ::std::os::raw::c_int,
    pub free: ::std::os::raw::c_int,
    pub objects: [YR_DICTIONARY_ITEMS__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_DICTIONARY_ITEMS__bindgen_ty_1 {
    pub key: *mut SIZED_STRING,
    pub obj: *mut YR_OBJECT,
}
#[test]
fn bindgen_test_layout_YR_DICTIONARY_ITEMS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_DICTIONARY_ITEMS__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(YR_DICTIONARY_ITEMS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_DICTIONARY_ITEMS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(YR_DICTIONARY_ITEMS__bindgen_ty_1)
        )
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_DICTIONARY_ITEMS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_DICTIONARY_ITEMS__bindgen_ty_1),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_obj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_DICTIONARY_ITEMS__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_DICTIONARY_ITEMS__bindgen_ty_1),
                "::",
                stringify!(obj)
            )
        );
    }
    test_field_obj();
}
impl Default for YR_DICTIONARY_ITEMS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_DICTIONARY_ITEMS() {
    assert_eq!(
        ::std::mem::size_of::<YR_DICTIONARY_ITEMS>(),
        24usize,
        concat!("Size of: ", stringify!(YR_DICTIONARY_ITEMS))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_DICTIONARY_ITEMS>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_DICTIONARY_ITEMS))
    );
    fn test_field_used() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_DICTIONARY_ITEMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).used) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_DICTIONARY_ITEMS),
                "::",
                stringify!(used)
            )
        );
    }
    test_field_used();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_DICTIONARY_ITEMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_DICTIONARY_ITEMS),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_objects() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_DICTIONARY_ITEMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objects) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_DICTIONARY_ITEMS),
                "::",
                stringify!(objects)
            )
        );
    }
    test_field_objects();
}
impl Default for YR_DICTIONARY_ITEMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_ITERATOR_NEXT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut YR_ITERATOR,
        stack: *mut YR_VALUE_STACK,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ARRAY_ITERATOR {
    pub array: *mut YR_OBJECT,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_YR_ARRAY_ITERATOR() {
    assert_eq!(
        ::std::mem::size_of::<YR_ARRAY_ITERATOR>(),
        16usize,
        concat!("Size of: ", stringify!(YR_ARRAY_ITERATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ARRAY_ITERATOR>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ARRAY_ITERATOR))
    );
    fn test_field_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARRAY_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARRAY_ITERATOR),
                "::",
                stringify!(array)
            )
        );
    }
    test_field_array();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ARRAY_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ARRAY_ITERATOR),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
}
impl Default for YR_ARRAY_ITERATOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_DICT_ITERATOR {
    pub dict: *mut YR_OBJECT,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_YR_DICT_ITERATOR() {
    assert_eq!(
        ::std::mem::size_of::<YR_DICT_ITERATOR>(),
        16usize,
        concat!("Size of: ", stringify!(YR_DICT_ITERATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_DICT_ITERATOR>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_DICT_ITERATOR))
    );
    fn test_field_dict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_DICT_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_DICT_ITERATOR),
                "::",
                stringify!(dict)
            )
        );
    }
    test_field_dict();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_DICT_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_DICT_ITERATOR),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
}
impl Default for YR_DICT_ITERATOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct YR_INT_RANGE_ITERATOR {
    pub next: i64,
    pub last: i64,
}
#[test]
fn bindgen_test_layout_YR_INT_RANGE_ITERATOR() {
    assert_eq!(
        ::std::mem::size_of::<YR_INT_RANGE_ITERATOR>(),
        16usize,
        concat!("Size of: ", stringify!(YR_INT_RANGE_ITERATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_INT_RANGE_ITERATOR>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_INT_RANGE_ITERATOR))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_INT_RANGE_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_INT_RANGE_ITERATOR),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_last() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_INT_RANGE_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_INT_RANGE_ITERATOR),
                "::",
                stringify!(last)
            )
        );
    }
    test_field_last();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct YR_INT_ENUM_ITERATOR {
    pub next: i64,
    pub count: i64,
    pub items: [i64; 1usize],
}
#[test]
fn bindgen_test_layout_YR_INT_ENUM_ITERATOR() {
    assert_eq!(
        ::std::mem::size_of::<YR_INT_ENUM_ITERATOR>(),
        24usize,
        concat!("Size of: ", stringify!(YR_INT_ENUM_ITERATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_INT_ENUM_ITERATOR>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_INT_ENUM_ITERATOR))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_INT_ENUM_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_INT_ENUM_ITERATOR),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_INT_ENUM_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_INT_ENUM_ITERATOR),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_items() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_INT_ENUM_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_INT_ENUM_ITERATOR),
                "::",
                stringify!(items)
            )
        );
    }
    test_field_items();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_STRING_SET_ITERATOR {
    pub count: i64,
    pub index: i64,
    pub strings: [*mut YR_STRING; 1usize],
}
#[test]
fn bindgen_test_layout_YR_STRING_SET_ITERATOR() {
    assert_eq!(
        ::std::mem::size_of::<YR_STRING_SET_ITERATOR>(),
        24usize,
        concat!("Size of: ", stringify!(YR_STRING_SET_ITERATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_STRING_SET_ITERATOR>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_STRING_SET_ITERATOR))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING_SET_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING_SET_ITERATOR),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING_SET_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING_SET_ITERATOR),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_STRING_SET_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_STRING_SET_ITERATOR),
                "::",
                stringify!(strings)
            )
        );
    }
    test_field_strings();
}
impl Default for YR_STRING_SET_ITERATOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct YR_ITERATOR {
    pub next_func_idx: ::std::os::raw::c_int,
    pub __bindgen_anon_1: YR_ITERATOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union YR_ITERATOR__bindgen_ty_1 {
    pub array_it: YR_ARRAY_ITERATOR,
    pub dict_it: YR_DICT_ITERATOR,
    pub int_range_it: YR_INT_RANGE_ITERATOR,
    pub int_enum_it: YR_INT_ENUM_ITERATOR,
    pub string_set_it: YR_STRING_SET_ITERATOR,
}
#[test]
fn bindgen_test_layout_YR_ITERATOR__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<YR_ITERATOR__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(YR_ITERATOR__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ITERATOR__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ITERATOR__bindgen_ty_1))
    );
    fn test_field_array_it() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ITERATOR__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array_it) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ITERATOR__bindgen_ty_1),
                "::",
                stringify!(array_it)
            )
        );
    }
    test_field_array_it();
    fn test_field_dict_it() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ITERATOR__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dict_it) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ITERATOR__bindgen_ty_1),
                "::",
                stringify!(dict_it)
            )
        );
    }
    test_field_dict_it();
    fn test_field_int_range_it() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ITERATOR__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_range_it) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ITERATOR__bindgen_ty_1),
                "::",
                stringify!(int_range_it)
            )
        );
    }
    test_field_int_range_it();
    fn test_field_int_enum_it() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ITERATOR__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int_enum_it) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ITERATOR__bindgen_ty_1),
                "::",
                stringify!(int_enum_it)
            )
        );
    }
    test_field_int_enum_it();
    fn test_field_string_set_it() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ITERATOR__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string_set_it) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ITERATOR__bindgen_ty_1),
                "::",
                stringify!(string_set_it)
            )
        );
    }
    test_field_string_set_it();
}
impl Default for YR_ITERATOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_YR_ITERATOR() {
    assert_eq!(
        ::std::mem::size_of::<YR_ITERATOR>(),
        32usize,
        concat!("Size of: ", stringify!(YR_ITERATOR))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ITERATOR>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ITERATOR))
    );
    fn test_field_next_func_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ITERATOR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_func_idx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ITERATOR),
                "::",
                stringify!(next_func_idx)
            )
        );
    }
    test_field_next_func_idx();
}
impl Default for YR_ITERATOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RE_MATCH_CALLBACK_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        match_: *const u8,
        match_length: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        args: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn yr_re_ast_create(re_ast: *mut *mut RE_AST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_ast_destroy(re_ast: *mut RE_AST);
}
extern "C" {
    pub fn yr_re_ast_print(re_ast: *mut RE_AST);
}
extern "C" {
    pub fn yr_re_ast_extract_literal(re_ast: *mut RE_AST) -> *mut SIZED_STRING;
}
extern "C" {
    pub fn yr_re_ast_has_unbounded_quantifier_for_dot(re_ast: *mut RE_AST)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_ast_split_at_chaining_point(
        re_ast: *mut RE_AST,
        remainder_re_ast: *mut *mut RE_AST,
        min_gap: *mut i32,
        max_gap: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_ast_emit_code(
        re_ast: *mut RE_AST,
        arena: *mut YR_ARENA,
        backwards_code: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_node_create(type_: ::std::os::raw::c_int) -> *mut RE_NODE;
}
extern "C" {
    pub fn yr_re_node_destroy(node: *mut RE_NODE);
}
extern "C" {
    pub fn yr_re_node_append_child(node: *mut RE_NODE, child: *mut RE_NODE);
}
extern "C" {
    pub fn yr_re_node_prepend_child(node: *mut RE_NODE, child: *mut RE_NODE);
}
extern "C" {
    pub fn yr_re_exec(
        context: *mut YR_SCAN_CONTEXT,
        code: *const u8,
        input_data: *const u8,
        input_forwards_size: size_t,
        input_backwards_size: size_t,
        flags: ::std::os::raw::c_int,
        callback: RE_MATCH_CALLBACK_FUNC,
        callback_args: *mut ::std::os::raw::c_void,
        matches: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_fast_exec(
        context: *mut YR_SCAN_CONTEXT,
        code: *const u8,
        input_data: *const u8,
        input_forwards_size: size_t,
        input_backwards_size: size_t,
        flags: ::std::os::raw::c_int,
        callback: RE_MATCH_CALLBACK_FUNC,
        callback_args: *mut ::std::os::raw::c_void,
        matches: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_parse(
        re_string: *const ::std::os::raw::c_char,
        re_ast: *mut *mut RE_AST,
        error: *mut RE_ERROR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_parse_hex(
        hex_string: *const ::std::os::raw::c_char,
        re_ast: *mut *mut RE_AST,
        error: *mut RE_ERROR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_compile(
        re_string: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        arena: *mut YR_ARENA,
        ref_: *mut YR_ARENA_REF,
        error: *mut RE_ERROR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_re_match(
        context: *mut YR_SCAN_CONTEXT,
        re: *mut RE,
        target: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct YR_ATOM {
    pub length: u8,
    pub bytes: [u8; 4usize],
    pub mask: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_YR_ATOM() {
    assert_eq!(
        ::std::mem::size_of::<YR_ATOM>(),
        9usize,
        concat!("Size of: ", stringify!(YR_ATOM))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ATOM>(),
        1usize,
        concat!("Alignment of ", stringify!(YR_ATOM))
    );
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM),
                "::",
                stringify!(bytes)
            )
        );
    }
    test_field_bytes();
    fn test_field_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM),
                "::",
                stringify!(mask)
            )
        );
    }
    test_field_mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ATOM_TREE_NODE {
    pub type_: u8,
    pub atom: YR_ATOM,
    pub re_nodes: [*mut RE_NODE; 4usize],
    pub children_head: *mut YR_ATOM_TREE_NODE,
    pub children_tail: *mut YR_ATOM_TREE_NODE,
    pub next_sibling: *mut YR_ATOM_TREE_NODE,
}
#[test]
fn bindgen_test_layout_YR_ATOM_TREE_NODE() {
    assert_eq!(
        ::std::mem::size_of::<YR_ATOM_TREE_NODE>(),
        72usize,
        concat!("Size of: ", stringify!(YR_ATOM_TREE_NODE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ATOM_TREE_NODE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ATOM_TREE_NODE))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_TREE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_TREE_NODE),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_atom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_TREE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atom) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_TREE_NODE),
                "::",
                stringify!(atom)
            )
        );
    }
    test_field_atom();
    fn test_field_re_nodes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_TREE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_nodes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_TREE_NODE),
                "::",
                stringify!(re_nodes)
            )
        );
    }
    test_field_re_nodes();
    fn test_field_children_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_TREE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children_head) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_TREE_NODE),
                "::",
                stringify!(children_head)
            )
        );
    }
    test_field_children_head();
    fn test_field_children_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_TREE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).children_tail) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_TREE_NODE),
                "::",
                stringify!(children_tail)
            )
        );
    }
    test_field_children_tail();
    fn test_field_next_sibling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_TREE_NODE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_sibling) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_TREE_NODE),
                "::",
                stringify!(next_sibling)
            )
        );
    }
    test_field_next_sibling();
}
impl Default for YR_ATOM_TREE_NODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ATOM_TREE {
    pub root_node: *mut YR_ATOM_TREE_NODE,
}
#[test]
fn bindgen_test_layout_YR_ATOM_TREE() {
    assert_eq!(
        ::std::mem::size_of::<YR_ATOM_TREE>(),
        8usize,
        concat!("Size of: ", stringify!(YR_ATOM_TREE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ATOM_TREE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ATOM_TREE))
    );
    fn test_field_root_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_TREE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_node) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_TREE),
                "::",
                stringify!(root_node)
            )
        );
    }
    test_field_root_node();
}
impl Default for YR_ATOM_TREE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ATOM_LIST_ITEM {
    pub atom: YR_ATOM,
    pub backtrack: u16,
    pub forward_code_ref: YR_ARENA_REF,
    pub backward_code_ref: YR_ARENA_REF,
    pub next: *mut YR_ATOM_LIST_ITEM,
}
#[test]
fn bindgen_test_layout_YR_ATOM_LIST_ITEM() {
    assert_eq!(
        ::std::mem::size_of::<YR_ATOM_LIST_ITEM>(),
        40usize,
        concat!("Size of: ", stringify!(YR_ATOM_LIST_ITEM))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ATOM_LIST_ITEM>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ATOM_LIST_ITEM))
    );
    fn test_field_atom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_LIST_ITEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atom) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_LIST_ITEM),
                "::",
                stringify!(atom)
            )
        );
    }
    test_field_atom();
    fn test_field_backtrack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_LIST_ITEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backtrack) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_LIST_ITEM),
                "::",
                stringify!(backtrack)
            )
        );
    }
    test_field_backtrack();
    fn test_field_forward_code_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_LIST_ITEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forward_code_ref) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_LIST_ITEM),
                "::",
                stringify!(forward_code_ref)
            )
        );
    }
    test_field_forward_code_ref();
    fn test_field_backward_code_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_LIST_ITEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backward_code_ref) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_LIST_ITEM),
                "::",
                stringify!(backward_code_ref)
            )
        );
    }
    test_field_backward_code_ref();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_LIST_ITEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_LIST_ITEM),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
impl Default for YR_ATOM_LIST_ITEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct YR_ATOM_QUALITY_TABLE_ENTRY {
    pub atom: [u8; 4usize],
    pub quality: u8,
}
#[test]
fn bindgen_test_layout_YR_ATOM_QUALITY_TABLE_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<YR_ATOM_QUALITY_TABLE_ENTRY>(),
        5usize,
        concat!("Size of: ", stringify!(YR_ATOM_QUALITY_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ATOM_QUALITY_TABLE_ENTRY>(),
        1usize,
        concat!("Alignment of ", stringify!(YR_ATOM_QUALITY_TABLE_ENTRY))
    );
    fn test_field_atom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_QUALITY_TABLE_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atom) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_QUALITY_TABLE_ENTRY),
                "::",
                stringify!(atom)
            )
        );
    }
    test_field_atom();
    fn test_field_quality() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOM_QUALITY_TABLE_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOM_QUALITY_TABLE_ENTRY),
                "::",
                stringify!(quality)
            )
        );
    }
    test_field_quality();
}
pub type YR_ATOMS_QUALITY_FUNC = ::std::option::Option<
    unsafe extern "C" fn(config: *mut YR_ATOMS_CONFIG, atom: *mut YR_ATOM) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_ATOMS_CONFIG {
    pub get_atom_quality: YR_ATOMS_QUALITY_FUNC,
    pub quality_table: *mut YR_ATOM_QUALITY_TABLE_ENTRY,
    pub quality_warning_threshold: ::std::os::raw::c_int,
    pub quality_table_entries: ::std::os::raw::c_int,
    pub free_quality_table: bool,
}
#[test]
fn bindgen_test_layout_YR_ATOMS_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<YR_ATOMS_CONFIG>(),
        32usize,
        concat!("Size of: ", stringify!(YR_ATOMS_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_ATOMS_CONFIG>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_ATOMS_CONFIG))
    );
    fn test_field_get_atom_quality() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOMS_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_atom_quality) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOMS_CONFIG),
                "::",
                stringify!(get_atom_quality)
            )
        );
    }
    test_field_get_atom_quality();
    fn test_field_quality_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOMS_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quality_table) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOMS_CONFIG),
                "::",
                stringify!(quality_table)
            )
        );
    }
    test_field_quality_table();
    fn test_field_quality_warning_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOMS_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quality_warning_threshold) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOMS_CONFIG),
                "::",
                stringify!(quality_warning_threshold)
            )
        );
    }
    test_field_quality_warning_threshold();
    fn test_field_quality_table_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOMS_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quality_table_entries) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOMS_CONFIG),
                "::",
                stringify!(quality_table_entries)
            )
        );
    }
    test_field_quality_table_entries();
    fn test_field_free_quality_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_ATOMS_CONFIG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free_quality_table) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_ATOMS_CONFIG),
                "::",
                stringify!(free_quality_table)
            )
        );
    }
    test_field_free_quality_table();
}
impl Default for YR_ATOMS_CONFIG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn yr_atoms_extract_from_re(
        config: *mut YR_ATOMS_CONFIG,
        re_ast: *mut RE_AST,
        modifier: YR_MODIFIER,
        atoms: *mut *mut YR_ATOM_LIST_ITEM,
        min_atom_quality: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_atoms_extract_from_string(
        config: *mut YR_ATOMS_CONFIG,
        string: *mut u8,
        string_length: ::std::os::raw::c_int,
        modifier: YR_MODIFIER,
        atoms: *mut *mut YR_ATOM_LIST_ITEM,
        min_atom_quality: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_atoms_extract_triplets(
        re_node: *mut RE_NODE,
        atoms: *mut *mut YR_ATOM_LIST_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_atoms_heuristic_quality(
        config: *mut YR_ATOMS_CONFIG,
        atom: *mut YR_ATOM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_atoms_table_quality(
        config: *mut YR_ATOMS_CONFIG,
        atom: *mut YR_ATOM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_atoms_min_quality(
        config: *mut YR_ATOMS_CONFIG,
        atom_list: *mut YR_ATOM_LIST_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_atoms_list_destroy(list_head: *mut YR_ATOM_LIST_ITEM);
}
extern "C" {
    pub fn yr_ac_automaton_create(
        arena: *mut YR_ARENA,
        automaton: *mut *mut YR_AC_AUTOMATON,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_ac_automaton_destroy(automaton: *mut YR_AC_AUTOMATON) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_ac_add_string(
        automaton: *mut YR_AC_AUTOMATON,
        string: *mut YR_STRING,
        string_idx: u32,
        atom: *mut YR_ATOM_LIST_ITEM,
        arena: *mut YR_ARENA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_ac_compile(
        automaton: *mut YR_AC_AUTOMATON,
        arena: *mut YR_ARENA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_ac_print_automaton(automaton: *mut YR_AC_AUTOMATON);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_MAPPED_FILE {
    pub file: ::std::os::raw::c_int,
    pub size: size_t,
    pub data: *const u8,
}
#[test]
fn bindgen_test_layout__YR_MAPPED_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_YR_MAPPED_FILE>(),
        24usize,
        concat!("Size of: ", stringify!(_YR_MAPPED_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_MAPPED_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_MAPPED_FILE))
    );
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_MAPPED_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_MAPPED_FILE),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_MAPPED_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_MAPPED_FILE),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_MAPPED_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_MAPPED_FILE),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for _YR_MAPPED_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_MAPPED_FILE = _YR_MAPPED_FILE;
extern "C" {
    pub fn yr_filemap_map(
        file_path: *const ::std::os::raw::c_char,
        pmapped_file: *mut YR_MAPPED_FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_filemap_map_fd(
        file: ::std::os::raw::c_int,
        offset: u64,
        size: size_t,
        pmapped_file: *mut YR_MAPPED_FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_filemap_map_ex(
        file_path: *const ::std::os::raw::c_char,
        offset: u64,
        size: size_t,
        pmapped_file: *mut YR_MAPPED_FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_filemap_unmap(pmapped_file: *mut YR_MAPPED_FILE);
}
extern "C" {
    pub fn yr_filemap_unmap_fd(pmapped_file: *mut YR_MAPPED_FILE);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _YR_EXPRESSION {
    pub type_: ::std::os::raw::c_int,
    pub value: _YR_EXPRESSION__bindgen_ty_1,
    pub identifier: _YR_EXPRESSION__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _YR_EXPRESSION__bindgen_ty_1 {
    pub integer: i64,
    pub object: *mut YR_OBJECT,
    pub sized_string_ref: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout__YR_EXPRESSION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_YR_EXPRESSION__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_YR_EXPRESSION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_EXPRESSION__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_EXPRESSION__bindgen_ty_1))
    );
    fn test_field_integer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION__bindgen_ty_1),
                "::",
                stringify!(integer)
            )
        );
    }
    test_field_integer();
    fn test_field_object() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION__bindgen_ty_1),
                "::",
                stringify!(object)
            )
        );
    }
    test_field_object();
    fn test_field_sized_string_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sized_string_ref) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION__bindgen_ty_1),
                "::",
                stringify!(sized_string_ref)
            )
        );
    }
    test_field_sized_string_ref();
}
impl Default for _YR_EXPRESSION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_EXPRESSION__bindgen_ty_2 {
    pub ptr: *const ::std::os::raw::c_char,
    pub ref_: YR_ARENA_REF,
}
#[test]
fn bindgen_test_layout__YR_EXPRESSION__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_YR_EXPRESSION__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(_YR_EXPRESSION__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_EXPRESSION__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_EXPRESSION__bindgen_ty_2))
    );
    fn test_field_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION__bindgen_ty_2),
                "::",
                stringify!(ptr)
            )
        );
    }
    test_field_ptr();
    fn test_field_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION__bindgen_ty_2),
                "::",
                stringify!(ref_)
            )
        );
    }
    test_field_ref();
}
impl Default for _YR_EXPRESSION__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__YR_EXPRESSION() {
    assert_eq!(
        ::std::mem::size_of::<_YR_EXPRESSION>(),
        32usize,
        concat!("Size of: ", stringify!(_YR_EXPRESSION))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_EXPRESSION>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_EXPRESSION))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_EXPRESSION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_EXPRESSION),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
}
impl Default for _YR_EXPRESSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_EXPRESSION = _YR_EXPRESSION;
pub type YR_COMPILER_CALLBACK_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        error_level: ::std::os::raw::c_int,
        file_name: *const ::std::os::raw::c_char,
        line_number: ::std::os::raw::c_int,
        rule: *const YR_RULE,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type YR_COMPILER_INCLUDE_CALLBACK_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        include_name: *const ::std::os::raw::c_char,
        calling_rule_filename: *const ::std::os::raw::c_char,
        calling_rule_namespace: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char,
>;
pub type YR_COMPILER_INCLUDE_FREE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        callback_result_ptr: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type YR_COMPILER_RE_AST_CALLBACK_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        rule: *const YR_RULE,
        string_identifier: *const ::std::os::raw::c_char,
        re_ast: *const RE_AST,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _YR_FIXUP {
    pub ref_: YR_ARENA_REF,
    pub next: *mut _YR_FIXUP,
}
#[test]
fn bindgen_test_layout__YR_FIXUP() {
    assert_eq!(
        ::std::mem::size_of::<_YR_FIXUP>(),
        16usize,
        concat!("Size of: ", stringify!(_YR_FIXUP))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_FIXUP>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_FIXUP))
    );
    fn test_field_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_FIXUP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_FIXUP),
                "::",
                stringify!(ref_)
            )
        );
    }
    test_field_ref();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_FIXUP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_FIXUP),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
impl Default for _YR_FIXUP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_FIXUP = _YR_FIXUP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _YR_LOOP_CONTEXT {
    pub start_ref: YR_ARENA_REF,
    pub vars_count: ::std::os::raw::c_int,
    pub vars: [YR_EXPRESSION; 2usize],
    pub vars_internal_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__YR_LOOP_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_YR_LOOP_CONTEXT>(),
        88usize,
        concat!("Size of: ", stringify!(_YR_LOOP_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_LOOP_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_LOOP_CONTEXT))
    );
    fn test_field_start_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_LOOP_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_ref) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_LOOP_CONTEXT),
                "::",
                stringify!(start_ref)
            )
        );
    }
    test_field_start_ref();
    fn test_field_vars_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_LOOP_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vars_count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_LOOP_CONTEXT),
                "::",
                stringify!(vars_count)
            )
        );
    }
    test_field_vars_count();
    fn test_field_vars() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_LOOP_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vars) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_LOOP_CONTEXT),
                "::",
                stringify!(vars)
            )
        );
    }
    test_field_vars();
    fn test_field_vars_internal_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_LOOP_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vars_internal_count) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_LOOP_CONTEXT),
                "::",
                stringify!(vars_internal_count)
            )
        );
    }
    test_field_vars_internal_count();
}
impl Default for _YR_LOOP_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_LOOP_CONTEXT = _YR_LOOP_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _YR_COMPILER {
    pub arena: *mut YR_ARENA,
    pub current_rule_idx: u32,
    pub next_rule_idx: u32,
    pub current_string_idx: u32,
    pub current_namespace_idx: u32,
    pub current_meta_idx: u32,
    pub rules: *mut YR_RULES,
    pub errors: ::std::os::raw::c_int,
    pub current_line: ::std::os::raw::c_int,
    pub last_error: ::std::os::raw::c_int,
    pub last_error_line: ::std::os::raw::c_int,
    pub error_recovery: jmp_buf,
    pub automaton: *mut YR_AC_AUTOMATON,
    pub rules_table: *mut YR_HASH_TABLE,
    pub objects_table: *mut YR_HASH_TABLE,
    pub strings_table: *mut YR_HASH_TABLE,
    pub wildcard_identifiers_table: *mut YR_HASH_TABLE,
    pub sz_table: *mut YR_HASH_TABLE,
    pub fixup_stack_head: *mut YR_FIXUP,
    pub num_namespaces: ::std::os::raw::c_int,
    pub loop_: [YR_LOOP_CONTEXT; 4usize],
    pub loop_index: ::std::os::raw::c_int,
    pub loop_for_of_var_index: ::std::os::raw::c_int,
    pub file_name_stack: [*mut ::std::os::raw::c_char; 16usize],
    pub file_name_stack_ptr: ::std::os::raw::c_int,
    pub last_error_extra_info: [::std::os::raw::c_char; 256usize],
    pub lex_buf: [::std::os::raw::c_char; 8192usize],
    pub lex_buf_ptr: *mut ::std::os::raw::c_char,
    pub lex_buf_len: ::std::os::raw::c_ushort,
    pub include_base_dir: [::std::os::raw::c_char; 1024usize],
    pub user_data: *mut ::std::os::raw::c_void,
    pub incl_clbk_user_data: *mut ::std::os::raw::c_void,
    pub re_ast_clbk_user_data: *mut ::std::os::raw::c_void,
    pub callback: YR_COMPILER_CALLBACK_FUNC,
    pub include_callback: YR_COMPILER_INCLUDE_CALLBACK_FUNC,
    pub include_free: YR_COMPILER_INCLUDE_FREE_FUNC,
    pub re_ast_callback: YR_COMPILER_RE_AST_CALLBACK_FUNC,
    pub atoms_config: YR_ATOMS_CONFIG,
}
#[test]
fn bindgen_test_layout__YR_COMPILER() {
    assert_eq!(
        ::std::mem::size_of::<_YR_COMPILER>(),
        10392usize,
        concat!("Size of: ", stringify!(_YR_COMPILER))
    );
    assert_eq!(
        ::std::mem::align_of::<_YR_COMPILER>(),
        8usize,
        concat!("Alignment of ", stringify!(_YR_COMPILER))
    );
    fn test_field_arena() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(arena)
            )
        );
    }
    test_field_arena();
    fn test_field_current_rule_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_rule_idx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(current_rule_idx)
            )
        );
    }
    test_field_current_rule_idx();
    fn test_field_next_rule_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next_rule_idx) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(next_rule_idx)
            )
        );
    }
    test_field_next_rule_idx();
    fn test_field_current_string_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_string_idx) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(current_string_idx)
            )
        );
    }
    test_field_current_string_idx();
    fn test_field_current_namespace_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_namespace_idx) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(current_namespace_idx)
            )
        );
    }
    test_field_current_namespace_idx();
    fn test_field_current_meta_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_meta_idx) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(current_meta_idx)
            )
        );
    }
    test_field_current_meta_idx();
    fn test_field_rules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rules) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(rules)
            )
        );
    }
    test_field_rules();
    fn test_field_errors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errors) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(errors)
            )
        );
    }
    test_field_errors();
    fn test_field_current_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_line) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(current_line)
            )
        );
    }
    test_field_current_line();
    fn test_field_last_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_error) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(last_error)
            )
        );
    }
    test_field_last_error();
    fn test_field_last_error_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_error_line) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(last_error_line)
            )
        );
    }
    test_field_last_error_line();
    fn test_field_error_recovery() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error_recovery) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(error_recovery)
            )
        );
    }
    test_field_error_recovery();
    fn test_field_automaton() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).automaton) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(automaton)
            )
        );
    }
    test_field_automaton();
    fn test_field_rules_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rules_table) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(rules_table)
            )
        );
    }
    test_field_rules_table();
    fn test_field_objects_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objects_table) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(objects_table)
            )
        );
    }
    test_field_objects_table();
    fn test_field_strings_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strings_table) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(strings_table)
            )
        );
    }
    test_field_strings_table();
    fn test_field_wildcard_identifiers_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wildcard_identifiers_table) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(wildcard_identifiers_table)
            )
        );
    }
    test_field_wildcard_identifiers_table();
    fn test_field_sz_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sz_table) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(sz_table)
            )
        );
    }
    test_field_sz_table();
    fn test_field_fixup_stack_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fixup_stack_head) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(fixup_stack_head)
            )
        );
    }
    test_field_fixup_stack_head();
    fn test_field_num_namespaces() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_namespaces) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(num_namespaces)
            )
        );
    }
    test_field_num_namespaces();
    fn test_field_loop() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loop_) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(loop_)
            )
        );
    }
    test_field_loop();
    fn test_field_loop_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loop_index) as usize - ptr as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(loop_index)
            )
        );
    }
    test_field_loop_index();
    fn test_field_loop_for_of_var_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loop_for_of_var_index) as usize - ptr as usize
            },
            676usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(loop_for_of_var_index)
            )
        );
    }
    test_field_loop_for_of_var_index();
    fn test_field_file_name_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_name_stack) as usize - ptr as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(file_name_stack)
            )
        );
    }
    test_field_file_name_stack();
    fn test_field_file_name_stack_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_name_stack_ptr) as usize - ptr as usize
            },
            808usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(file_name_stack_ptr)
            )
        );
    }
    test_field_file_name_stack_ptr();
    fn test_field_last_error_extra_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_error_extra_info) as usize - ptr as usize
            },
            812usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(last_error_extra_info)
            )
        );
    }
    test_field_last_error_extra_info();
    fn test_field_lex_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lex_buf) as usize - ptr as usize
            },
            1068usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(lex_buf)
            )
        );
    }
    test_field_lex_buf();
    fn test_field_lex_buf_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lex_buf_ptr) as usize - ptr as usize
            },
            9264usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(lex_buf_ptr)
            )
        );
    }
    test_field_lex_buf_ptr();
    fn test_field_lex_buf_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lex_buf_len) as usize - ptr as usize
            },
            9272usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(lex_buf_len)
            )
        );
    }
    test_field_lex_buf_len();
    fn test_field_include_base_dir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).include_base_dir) as usize - ptr as usize
            },
            9274usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(include_base_dir)
            )
        );
    }
    test_field_include_base_dir();
    fn test_field_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize
            },
            10304usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(user_data)
            )
        );
    }
    test_field_user_data();
    fn test_field_incl_clbk_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).incl_clbk_user_data) as usize - ptr as usize
            },
            10312usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(incl_clbk_user_data)
            )
        );
    }
    test_field_incl_clbk_user_data();
    fn test_field_re_ast_clbk_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_ast_clbk_user_data) as usize - ptr as usize
            },
            10320usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(re_ast_clbk_user_data)
            )
        );
    }
    test_field_re_ast_clbk_user_data();
    fn test_field_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize
            },
            10328usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(callback)
            )
        );
    }
    test_field_callback();
    fn test_field_include_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).include_callback) as usize - ptr as usize
            },
            10336usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(include_callback)
            )
        );
    }
    test_field_include_callback();
    fn test_field_include_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).include_free) as usize - ptr as usize
            },
            10344usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(include_free)
            )
        );
    }
    test_field_include_free();
    fn test_field_re_ast_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_ast_callback) as usize - ptr as usize
            },
            10352usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(re_ast_callback)
            )
        );
    }
    test_field_re_ast_callback();
    fn test_field_atoms_config() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_YR_COMPILER>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atoms_config) as usize - ptr as usize
            },
            10360usize,
            concat!(
                "Offset of field: ",
                stringify!(_YR_COMPILER),
                "::",
                stringify!(atoms_config)
            )
        );
    }
    test_field_atoms_config();
}
impl Default for _YR_COMPILER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type YR_COMPILER = _YR_COMPILER;
extern "C" {
    pub fn yr_compiler_create(compiler: *mut *mut YR_COMPILER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_destroy(compiler: *mut YR_COMPILER);
}
extern "C" {
    pub fn yr_compiler_set_callback(
        compiler: *mut YR_COMPILER,
        callback: YR_COMPILER_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn yr_compiler_set_include_callback(
        compiler: *mut YR_COMPILER,
        include_callback: YR_COMPILER_INCLUDE_CALLBACK_FUNC,
        include_free: YR_COMPILER_INCLUDE_FREE_FUNC,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn yr_compiler_set_re_ast_callback(
        compiler: *mut YR_COMPILER,
        re_ast_callback: YR_COMPILER_RE_AST_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn yr_compiler_set_atom_quality_table(
        compiler: *mut YR_COMPILER,
        table: *const ::std::os::raw::c_void,
        entries: ::std::os::raw::c_int,
        warning_threshold: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn yr_compiler_load_atom_quality_table(
        compiler: *mut YR_COMPILER,
        filename: *const ::std::os::raw::c_char,
        warning_threshold: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_add_file(
        compiler: *mut YR_COMPILER,
        rules_file: *mut FILE,
        namespace_: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_add_fd(
        compiler: *mut YR_COMPILER,
        rules_fd: ::std::os::raw::c_int,
        namespace_: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_add_string(
        compiler: *mut YR_COMPILER,
        rules_string: *const ::std::os::raw::c_char,
        namespace_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_get_error_message(
        compiler: *mut YR_COMPILER,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn yr_compiler_get_current_file_name(
        compiler: *mut YR_COMPILER,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn yr_compiler_define_integer_variable(
        compiler: *mut YR_COMPILER,
        identifier: *const ::std::os::raw::c_char,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_define_boolean_variable(
        compiler: *mut YR_COMPILER,
        identifier: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_define_float_variable(
        compiler: *mut YR_COMPILER,
        identifier: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_define_string_variable(
        compiler: *mut YR_COMPILER,
        identifier: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_compiler_get_rules(
        compiler: *mut YR_COMPILER,
        rules: *mut *mut YR_RULES,
    ) -> ::std::os::raw::c_int;
}
pub const _YR_CONFIG_NAME_YR_CONFIG_STACK_SIZE: _YR_CONFIG_NAME = 0;
pub const _YR_CONFIG_NAME_YR_CONFIG_MAX_STRINGS_PER_RULE: _YR_CONFIG_NAME = 1;
pub const _YR_CONFIG_NAME_YR_CONFIG_MAX_MATCH_DATA: _YR_CONFIG_NAME = 2;
pub const _YR_CONFIG_NAME_YR_CONFIG_MAX_PROCESS_MEMORY_CHUNK: _YR_CONFIG_NAME = 3;
pub const _YR_CONFIG_NAME_YR_CONFIG_LAST: _YR_CONFIG_NAME = 4;
pub type _YR_CONFIG_NAME = ::std::os::raw::c_uint;
pub use self::_YR_CONFIG_NAME as YR_CONFIG_NAME;
extern "C" {
    pub fn yr_initialize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_finalize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_set_configuration(
        arg1: YR_CONFIG_NAME,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_set_configuration_uint32(arg1: YR_CONFIG_NAME, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_set_configuration_uint64(arg1: YR_CONFIG_NAME, arg2: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_get_configuration(
        arg1: YR_CONFIG_NAME,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_get_configuration_uint32(
        arg1: YR_CONFIG_NAME,
        arg2: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_get_configuration_uint64(
        arg1: YR_CONFIG_NAME,
        arg2: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_calloc(count: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn yr_strdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn yr_strndup(
        str_: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn yr_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn yr_heap_alloc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_heap_free() -> ::std::os::raw::c_int;
}
pub type YR_SCANNER = YR_SCAN_CONTEXT;
extern "C" {
    pub fn yr_scanner_create(
        rules: *mut YR_RULES,
        scanner: *mut *mut YR_SCANNER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_destroy(scanner: *mut YR_SCANNER);
}
extern "C" {
    pub fn yr_scanner_set_callback(
        scanner: *mut YR_SCANNER,
        callback: YR_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn yr_scanner_set_timeout(scanner: *mut YR_SCANNER, timeout: ::std::os::raw::c_int);
}
extern "C" {
    pub fn yr_scanner_set_flags(scanner: *mut YR_SCANNER, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn yr_scanner_define_integer_variable(
        scanner: *mut YR_SCANNER,
        identifier: *const ::std::os::raw::c_char,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_define_boolean_variable(
        scanner: *mut YR_SCANNER,
        identifier: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_define_float_variable(
        scanner: *mut YR_SCANNER,
        identifier: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_define_string_variable(
        scanner: *mut YR_SCANNER,
        identifier: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_scan_mem_blocks(
        scanner: *mut YR_SCANNER,
        iterator: *mut YR_MEMORY_BLOCK_ITERATOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_scan_mem(
        scanner: *mut YR_SCANNER,
        buffer: *const u8,
        buffer_size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_scan_file(
        scanner: *mut YR_SCANNER,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_scan_fd(
        scanner: *mut YR_SCANNER,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_scan_proc(
        scanner: *mut YR_SCANNER,
        pid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scanner_last_error_rule(scanner: *mut YR_SCANNER) -> *mut YR_RULE;
}
extern "C" {
    pub fn yr_scanner_last_error_string(scanner: *mut YR_SCANNER) -> *mut YR_STRING;
}
extern "C" {
    pub fn yr_scanner_get_profiling_info(scanner: *mut YR_SCANNER) -> *mut YR_RULE_PROFILING_INFO;
}
extern "C" {
    pub fn yr_scanner_reset_profiling_info(scanner: *mut YR_SCANNER);
}
extern "C" {
    pub fn yr_scanner_print_profiling_info(scanner: *mut YR_SCANNER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_scan_mem_blocks(
        rules: *mut YR_RULES,
        iterator: *mut YR_MEMORY_BLOCK_ITERATOR,
        flags: ::std::os::raw::c_int,
        callback: YR_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_scan_mem(
        rules: *mut YR_RULES,
        buffer: *const u8,
        buffer_size: size_t,
        flags: ::std::os::raw::c_int,
        callback: YR_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_scan_file(
        rules: *mut YR_RULES,
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        callback: YR_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_scan_fd(
        rules: *mut YR_RULES,
        fd: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        callback: YR_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_scan_proc(
        rules: *mut YR_RULES,
        pid: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        callback: YR_CALLBACK_FUNC,
        user_data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_save(
        rules: *mut YR_RULES,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_save_stream(
        rules: *mut YR_RULES,
        stream: *mut YR_STREAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_load(
        filename: *const ::std::os::raw::c_char,
        rules: *mut *mut YR_RULES,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_load_stream(
        stream: *mut YR_STREAM,
        rules: *mut *mut YR_RULES,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_destroy(rules: *mut YR_RULES) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_define_integer_variable(
        rules: *mut YR_RULES,
        identifier: *const ::std::os::raw::c_char,
        value: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_define_boolean_variable(
        rules: *mut YR_RULES,
        identifier: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_define_float_variable(
        rules: *mut YR_RULES,
        identifier: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_define_string_variable(
        rules: *mut YR_RULES,
        identifier: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rules_get_stats(
        rules: *mut YR_RULES,
        stats: *mut YR_RULES_STATS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_rule_disable(rule: *mut YR_RULE);
}
extern "C" {
    pub fn yr_rule_enable(rule: *mut YR_RULE);
}
extern "C" {
    pub fn yr_rules_from_arena(
        arena: *mut YR_ARENA,
        rules: *mut *mut YR_RULES,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_scan_verify_match(
        context: *mut YR_SCAN_CONTEXT,
        ac_match: *mut YR_AC_MATCH,
        data: *const u8,
        data_size: size_t,
        data_base: u64,
        offset: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_execute_code(context: *mut YR_SCAN_CONTEXT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_create(
        type_: i8,
        identifier: *const ::std::os::raw::c_char,
        parent: *mut YR_OBJECT,
        object: *mut *mut YR_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_set_canary(object: *mut YR_OBJECT, canary: ::std::os::raw::c_int);
}
extern "C" {
    pub fn yr_object_function_create(
        identifier: *const ::std::os::raw::c_char,
        arguments_fmt: *const ::std::os::raw::c_char,
        return_fmt: *const ::std::os::raw::c_char,
        func: YR_MODULE_FUNC,
        parent: *mut YR_OBJECT,
        function: *mut *mut YR_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_from_external_variable(
        external: *mut YR_EXTERNAL_VARIABLE,
        object: *mut *mut YR_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_destroy(object: *mut YR_OBJECT);
}
extern "C" {
    pub fn yr_object_copy(
        object: *mut YR_OBJECT,
        object_copy: *mut *mut YR_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_lookup_field(
        object: *mut YR_OBJECT,
        field_name: *const ::std::os::raw::c_char,
    ) -> *mut YR_OBJECT;
}
extern "C" {
    pub fn yr_object_lookup(
        root: *mut YR_OBJECT,
        flags: ::std::os::raw::c_int,
        pattern: *const ::std::os::raw::c_char,
        ...
    ) -> *mut YR_OBJECT;
}
extern "C" {
    pub fn yr_object_has_undefined_value(
        object: *mut YR_OBJECT,
        field: *const ::std::os::raw::c_char,
        ...
    ) -> bool;
}
extern "C" {
    pub fn yr_object_get_float(
        object: *mut YR_OBJECT,
        field: *const ::std::os::raw::c_char,
        ...
    ) -> f64;
}
extern "C" {
    pub fn yr_object_get_integer(
        object: *mut YR_OBJECT,
        field: *const ::std::os::raw::c_char,
        ...
    ) -> i64;
}
extern "C" {
    pub fn yr_object_get_string(
        object: *mut YR_OBJECT,
        field: *const ::std::os::raw::c_char,
        ...
    ) -> *mut SIZED_STRING;
}
extern "C" {
    pub fn yr_object_set_integer(
        value: i64,
        object: *mut YR_OBJECT,
        field: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_set_float(
        value: f64,
        object: *mut YR_OBJECT,
        field: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_set_string(
        value: *const ::std::os::raw::c_char,
        len: size_t,
        object: *mut YR_OBJECT,
        field: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_array_length(object: *mut YR_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_array_get_item(
        object: *mut YR_OBJECT,
        flags: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
    ) -> *mut YR_OBJECT;
}
extern "C" {
    pub fn yr_object_array_set_item(
        object: *mut YR_OBJECT,
        item: *mut YR_OBJECT,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_dict_get_item(
        object: *mut YR_OBJECT,
        flags: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
    ) -> *mut YR_OBJECT;
}
extern "C" {
    pub fn yr_object_dict_set_item(
        object: *mut YR_OBJECT,
        item: *mut YR_OBJECT,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_structure_set_member(
        object: *mut YR_OBJECT,
        member: *mut YR_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_object_get_root(object: *mut YR_OBJECT) -> *mut YR_OBJECT;
}
extern "C" {
    pub fn yr_object_print_data(
        object: *mut YR_OBJECT,
        indent: ::std::os::raw::c_int,
        print_identifier: ::std::os::raw::c_int,
    );
}
pub type YR_EXT_INITIALIZE_FUNC =
    ::std::option::Option<unsafe extern "C" fn(module: *mut YR_MODULE) -> ::std::os::raw::c_int>;
pub type YR_EXT_FINALIZE_FUNC =
    ::std::option::Option<unsafe extern "C" fn(module: *mut YR_MODULE) -> ::std::os::raw::c_int>;
pub type YR_EXT_DECLARATIONS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(module_object: *mut YR_OBJECT) -> ::std::os::raw::c_int,
>;
pub type YR_EXT_LOAD_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut YR_SCAN_CONTEXT,
        module_object: *mut YR_OBJECT,
        module_data: *mut ::std::os::raw::c_void,
        module_data_size: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type YR_EXT_UNLOAD_FUNC = ::std::option::Option<
    unsafe extern "C" fn(module_object: *mut YR_OBJECT) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_MODULE {
    pub name: *mut ::std::os::raw::c_char,
    pub declarations: YR_EXT_DECLARATIONS_FUNC,
    pub load: YR_EXT_LOAD_FUNC,
    pub unload: YR_EXT_UNLOAD_FUNC,
    pub initialize: YR_EXT_INITIALIZE_FUNC,
    pub finalize: YR_EXT_FINALIZE_FUNC,
}
#[test]
fn bindgen_test_layout_YR_MODULE() {
    assert_eq!(
        ::std::mem::size_of::<YR_MODULE>(),
        48usize,
        concat!("Size of: ", stringify!(YR_MODULE))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_MODULE>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_MODULE))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_declarations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).declarations) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE),
                "::",
                stringify!(declarations)
            )
        );
    }
    test_field_declarations();
    fn test_field_load() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE),
                "::",
                stringify!(load)
            )
        );
    }
    test_field_load();
    fn test_field_unload() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unload) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE),
                "::",
                stringify!(unload)
            )
        );
    }
    test_field_unload();
    fn test_field_initialize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE),
                "::",
                stringify!(initialize)
            )
        );
    }
    test_field_initialize();
    fn test_field_finalize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE),
                "::",
                stringify!(finalize)
            )
        );
    }
    test_field_finalize();
}
impl Default for YR_MODULE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct YR_MODULE_IMPORT {
    pub module_name: *const ::std::os::raw::c_char,
    pub module_data: *mut ::std::os::raw::c_void,
    pub module_data_size: size_t,
}
#[test]
fn bindgen_test_layout_YR_MODULE_IMPORT() {
    assert_eq!(
        ::std::mem::size_of::<YR_MODULE_IMPORT>(),
        24usize,
        concat!("Size of: ", stringify!(YR_MODULE_IMPORT))
    );
    assert_eq!(
        ::std::mem::align_of::<YR_MODULE_IMPORT>(),
        8usize,
        concat!("Alignment of ", stringify!(YR_MODULE_IMPORT))
    );
    fn test_field_module_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE_IMPORT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE_IMPORT),
                "::",
                stringify!(module_name)
            )
        );
    }
    test_field_module_name();
    fn test_field_module_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE_IMPORT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE_IMPORT),
                "::",
                stringify!(module_data)
            )
        );
    }
    test_field_module_data();
    fn test_field_module_data_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<YR_MODULE_IMPORT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module_data_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(YR_MODULE_IMPORT),
                "::",
                stringify!(module_data_size)
            )
        );
    }
    test_field_module_data_size();
}
impl Default for YR_MODULE_IMPORT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn yr_modules_initialize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_modules_finalize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_modules_do_declarations(
        module_name: *const ::std::os::raw::c_char,
        main_structure: *mut YR_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_modules_load(
        module_name: *const ::std::os::raw::c_char,
        context: *mut YR_SCAN_CONTEXT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_modules_do_load(
        module_name: *const ::std::os::raw::c_char,
        module_structure: *mut YR_OBJECT,
        context: *mut YR_SCAN_CONTEXT,
        module_import: *mut YR_MODULE_IMPORT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_modules_unload_all(context: *mut YR_SCAN_CONTEXT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_modules_do_unload(
        module_name: *const ::std::os::raw::c_char,
        module_structure: *mut YR_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_isalnum(s: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn yr_vasprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn yr_asprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
